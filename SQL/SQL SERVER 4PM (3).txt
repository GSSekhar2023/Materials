Database :-
--------------

=> a  database is a organized collection of interrelated data , for example a univ db 
      stores data related to students,courses,faculty etc.

 Types of DB :- 
 -----------------

   1  OLTP  DB   (online transaction processing) 
   2  OLAP DB   (online analytical processing)

 => OLTP db is for storing day-to-day transactions and OLAP for data analysis.
 => OLTP is for running business and OLAP is for analyzing business.
 => day-to-day operations on db includes

    C   create
    R   read
    U   update
    D   delete

 DBMS :- 
 ------------

 => DBMS stands for Database Management System  , It is a software used to 
      create and to manage database.

   Evolution of DBMS :- 
   ----------------------------

   1960		 FMS   (File Mgmt System)

   1970		HDBMS (Hierarchical DBMS)
		NDBMS (Network DBMS)
 
   1980		RDBMS (Relational DBMS)

   1990		ORDBMS (Object Relational DBMS)

  
 RDBMS :- 
 --------------

 => RDBMS concepts are introduced by E.F.CODD
 => according to E.F.CODD in rdbms data must be organized in tables i.e. rows and columns
 
   CUST
   CID	NAME	ADDR  => column/field/attribute
   1	SACHIN  MUM
   2	RAHUL	DEL
   3	VIJAY	HYD  => row/record/tuple
   
     DB     		 =    collection of tables 
     TABLE		 =    collection of rows & columns
     ROW                   =    collection of field values
     COLUMN            =    collection of values assigned to one field

   => every table must contain primary key to uniquely identify the records.

             ex :-  accno,empid,aadharno,panno,voterid
 
  RDBMS features :-  
  -------------------------

   1   easy to access & manipulate data
   2   less  redundency (duplication of data) 
   3   more security 
   4   guranteess data quality or data consistency
   5   supports data sharing
   6   supports transactions 

 RDBMS softwares :-   (SQL databases)
 ----------------------------
 
 SQL SERVER         from microsoft
 ORACLE                 from oracle corp
 DB2                         from ibm
 MYSQL                   from oracle corp
 POSTGRESQL       from postgresql forum

 25-MAR-23

 ORDBMS :-  
 -----------------

 =>  object relational database management system
 =>  it is the combination of rdbms & oops 

            ORDBMS =   RDBMS + OOPS (reusability)

 =>  RDBMS doesn't support reusability but ORDBMS supports reusability.

  RDBMS :- 
  ---------------

  CUST
  CID    NAME    HNO   STREET   CITY   STATE    PIN

  EMP
  EMPID  ENAME  HNO  STREET  CITY   STATE   PIN

  STUDENT
  SID      SNAME    HNO  STREET   CITY   STATE   PIN

 => in the above example  in all the three tables address is repeated and when 
      addr repeated  we need to repeat 5 fields 

  ORDBMS :- 
  ----------------

 TABLE :-

        ADDR   
        HNO      STREET    CITY    STATE    PIN


 CUST
 CID     NAME      ADDR

EMP
 EMPID  ENAME   ADDR

STUDENT
SID    NAME         ADDR 

=> in above example when address repeated then we need to repeat only one field

 ORDBMS softwares :- 
 ------------------------------

  SQL SERVER 
  ORACLE
  POSTGRESQL

 what is SQL SERVER ?

  => SQL SERVER is basically a rdbms product  from microsoft and also 
        supports ordbms features and used to maintain database.

 DB DEVELOPMENT LIFE CYCLE :- 
 -----------------------------------------------

 1  ANALYSIS
 2  DESIGN
 3  DEVELOPMENT 
 4  TESTING
 5  IMPLEMENTATION
 6  MAINTENANCE

 DB DESIGN :- 
 --------------------

  => designing db means designing tables.
  => db is designed by DB Designer/Architect.
  => db designer designs db by using

       1  ER MODEL (Entity Relationship Model)
       2  NORMALIZATION 
  
DEVELOPMENT :- 
-------------------------

 => Development means creating tables in sql server.
 => DB is developed by Developers & DBAs by using SQL SERVER,ORACLE,MYSQL etc
 
       	    Developer                                              DBA  (Database Admin)

      1            creating tables			 installation of sql server
      2            creating views			 creating database
      3            creating synonyms                                creating logins 
      4            creating sequences                               db backup & restore
      5            creating indexes                                    db export & import
      6            creating procedures                              db upgradation & migration
      7            creating functions                                 performance tuning               
      8            creting triggers 
      9            writing queries


     sql server 2014  ========> sql server 2019     =>   db upgradation

     mysql ==================> sql server       =>    db migration

 
  =>  db is tested by QA teams (Quality Assurance) by using some tools called
        testing tools 

 =>  implementation means moving db from DEV server to PROD server.

=====================================================================

 			SQL SERVER
                                                ===========

  => SQL SERVER is a rdbms product from microsoft  and also supports ordbms features
       and used to create and to manage database.

 =>  SQL SERVER is used for DB Development & Administration.

 versions of sql server :- 
 ------------------------------

 version                                 year

  SQL SERVER 1.1               1991
  SQL SERVER 4.2               1993
  SQL SERVER 6.0               1995
  SQL SERVER 6.5               1996
  SQL SERVER 7.0               1998
  SQL SERVER 2000             2000
  SQL SERVER 2005             2005
  SQL SERVER 2008             2008
  SQL SERVER 2012             2012
  SQL SERVER 2014             2014
  SQL SERVER 2016             2016   
  SQL SERVER 2017             2017
  SQL SERVER 2019             2019

 sql server 2016 :- 

  1 polybase
  2 json (javascript object notation)
  3 temporal table to save data changes.
  4 dynamic data masking and row level security
  
 sql server 2017 :- 

  1 identity cache
  2 New String functions
  3 Automatic Tuning

 sql server 2019 :- 

1  Read, write, and process big data from Transact-SQL
2  Easily combine and analyze high-value relational data with high-volume big data.
3  Query external data sources.
4  Store big data in HDFS managed by SQL Server.
5  Query data from multiple external data 

 CLIENT/SERVER  Architecture :- 
 -------------------------------------------

 1    SERVER
 2    CLIENT

 SERVER :- 
 ---------------

 => server is a system where sql server software is installed and running.
 => server manages the following two components 
  
     1   DB
     2   INSTANCE

  => DB is created in hard disk and acts as permanent storage.
 => INSTANCE is created in ram and acts as temporary storage.
 
 CLIENT :- 
 -------------

  => client is also a system where users can 

  1  connects to server
  2  submit the requests 
  3  receives response

client tool :- 
---------------

  SSMS   (SQL SERVER MANAGEMENT STUDIO)


 USER----SSMS--------------------------------SQL SERVER----------DB

 USER---SQLPLUS----------------------------ORACLE------------------DB

USER--MYSQLWORKBENCH--------------MYSQL-------------------DB


SQL :- 
---------

 => SQL stands for structured query language.
 => it is a language used to communicate with sql server. 
 => user communicates with sql server by sending commands called queries.
 => a query is a command/instruction/question given to sql server to perform some 
      operation on db.
 => SQL is originally introduced by IBM and initial name of this language was "SEQUEL"
      and later it is renamed to SQL.
 
  => SQL is common to all  rdbms                

       SQL SERVER       ORACLE           MYSQL         DB2
             SQL                     SQL                 SQL              SQL  


     USER-----SSMS-------------SQL------------------SQL SERVER----------DB
                     tool                    lang                       software                     storage

  => based on operations over db  SQL is categorized into following sublanguages.

      DDL  (DATA DEFINITION LANG)
      DML (DATA MANIPULATION LANG)
      DQL (DATA QUERY LANG)  
      TCL  (TRANSACTION CONTROL LANG)
      DCL (DATA CONTROL LANG)

 				SQL


 	DDL		DML	DQL	TCL		DCL
	
	create		insert	select	commit		grant
	alter		update		rollback		revoke
	drop		delete		save transaction
	truncate		merge


28-MAR-23
 
   DATA  & DATA DEFINITION :-
  ---------------------------------------


EMPID	ENAME		SALARY	=> DATA DEFINITION
   1	SACHIN		8000    	=> DATA 

 How to connect to sql server :- 
 ----------------------------------------

  => to connect to sql server open SSMS and enter following details 

 	 SERVER  TYPE   		 :-   DB ENGINE
                 SERVER NAME   		 :-   DESKTOP-G2DM7GI
                 AUTHENTICATION		 :-   SQL SERVER / WINDOWS
                 LOGIN			 :-   SA (system admin)
                 PASSWORD		:-    123

  => click  connect.

  CREATING DATABASE IN SQL SERVER :- 
  --------------------------------------------------------
 
   =>  to create new database  , select  databases => New Database
 
	 enter database name :-  DB4PM

     =>  click  OK

     => a  DB is created with following two files 


              1  DATA FILE (.MDF)       (MASTER DATA FILE)
              2  LOG FILE  (.LDF)        (LOG DATA FILE)

    => DATA FILE stores data  and LOG file stores operations.

      NAME	TYPE	  INITIAL SIZE                 AUTOGROWTH
      DB4PM	DATA	  8MB		        64MB
      DB4PM_LOG	LOG	  8MB		        64MB

       PATH :- 
       ------------

       C:\Program Files\Microsoft SQL Server\MSSQL15.MSSQLSERVER\MSSQL\DATA\
 
    INSTALLATION :- 
    ---------------------


 => following softwares needs to be installed  to work with sql server db

    1  SQL SERVER
    2  SSMS 

    downloading sql server :- 
     ---------------------------------

    https://www.microsoft.com/en-in/sql-server/sql-server-downloads
            
    step by step installation of sql server :- 
    ----------------------------------------------------

  https://www.c-sharpcorner.com/article/step-by-step-installation-of-microsoft-sql-server-on-windows-system/

  
 downloading ssms :- 
 --------------------------

https://learn.microsoft.com

29-mar-23

Datatypes in SQL SERVER :- 
---------------------------------------

=>  a  Datatype specifies

   1  type of the data allowed
   2  amount of memory allocated

  CHARACTER  types :- 
  ----------------------------

                              ASCII                                        UNICODE

                             char			nchar
                             varchar                                       nvarchar
                             varchar(max)                              nvarchar(max)

           ASCII   => american standard code for information interchange

 char :- 
 --------
     
 => allows character data upto 8000 chars
 => recommended for fixed length char columns 

    ex :-   NAME    CHAR(10)

              sachin---- 
                        wasted

              ravi------
                       wasted

   => in char datatype extra bytes are wasted , so char is not recommended
        for variable length fields and it is recommended for fixed length fields.

               GENDER    CHAR(1)
 
                M
                F

	STATE_CODE	CHAR(2)

	AP
                TS
                MH

	COUNTRY_CODE	 CHAR(3)

	IND
	USA
                ENG
 
 VARCHAR :- 
 -----------------

  => varchar allows character data upto 8000 chars
  => recommended for variable length fields.

       ex :-    NAME	  VARCHAR(10)

                  sachin----
                               released

 => in varchar extra bytes are released

 VARCHAR(MAX) :- 
 -------------------------

 => allows character data upto 2GB.

                       
   1 TB = 1024 GB
   1 GB = 1024 MB
   1 MB = 1024 KB
   1 KB = 1024 BYES 

 2*1024*1024*1024 BYTES

=> char/varchar/varchar(max) allows  ascii chars (256 chars) that includes
     a-z,A-Z,0-9,special chars.

            ex :-    PANNO      CHAR(10)
                       VEHNO     CHAR(10)
                       EMAILID    VARCHAR(20)
  
NCHAR/NVARCHAR/NVARCHAR(MAX) :- 
-------------------------------------------------------

=>  allows unicode chars (65536 ) that includes all ascii and chars belongs to
      different languages.

 Integer Types :- 
 --------------------

 => allows  numbers  without  decimal part

      TINYINT	 1 BYTE		0 TO 255
      SMALLINT	 2 BYTES                -32768 TO 32767
      INT		 4 BYTES	               -2147483648 to 2147483647
      BIGINT	 8 BYTES                -9223372036854775808 to 9223372036854775807
 
        ex :- 
                    AGE    		TINYINT
                    EMPID		SMALLINT
	    ACCNO	BIGINT

 NUMERIC(P) :- 
 --------------------

  => allows numbers without decimal part.
  => use this datatype when value is based on number of digits
  => allows  numbers upto 38 digits

      ex :-      empid    NUMERIC(4)

                    10         VALID
                    100       VALID
                   1000      VALID
                   10000    INVALID

                    PHONE    	NUMERIC(10)
                    ACCNO    	NUMERIC(11)
                    AADHARNO	NUMERIC(12)
                    
 NUMERIC(P,S) / DECIMAL(P,S) :- 
 ---------------------------------------------

 => allows numbers with decimal part ( float)

    P  => precision => total no of digits allowed
    S  => scale       => no of digits allowed after decimal

    ex :-      SALARY      NUMERIC(7,2)

                 5000           VALID
                 5000.55	    VALID
                50000.55      VALID
               500000.50     INVALID

                   5000.507   VALID  => 5000.51
                   5000.503   VALID  => 5000.50

 NOTE :-   if before decimal exceeds number is not accepted
                 if after decimal exceeds number is rounded
 
 CURRENCY types :- 
 ----------------------------

 =>  currency types are used for fields related to money

       SMALLMONEY	  4 BYTES      -2,14,748.3648 to 2,14,748.3647	
       MONEY	  8 BYTES      -922337203685477.5808 to 922337203685477.5807


   EX :-    SALARY    	SMALLMONEY
               BALANCE		MONEY
               AMOUNT		SMALLMONEY
               PRICE		SMALLMONEY

30-mar-23

 DATE & TIME :-  
 --------------------

 1   DATE                  =>   allows only date
 2   TIME                   =>   allows only time
 3   DATETIME          =>   allows date & time

 =>  default date format in sql server is YYYY-MM-DD
 =>  default time format is HH:MI:SS

   EX :-       HIREDATE        DATE

                  2023-03-30
 
                  LOGIN             TIME       

                  10:00:00

                   TXNDT            DATETIME

	   2023-03-30 11:00:00

 Binary Types :-  
 ---------------------

 => Binary types are used for storing multimedia objects like  audio,video,images

     1   binary                   =>  allows upto 8000 bytes
     2   varbinary              =>  allows upto 8000 bytes 
     3   varbinary(max)     =>  allows upto 2GB

  =>  in binary extra bytes are wasted but in varbinary extra bytes are released

       ex :-    photo    binary(1000)
                
                  photo    varbinary(1000)

                  video    varbinary(max) 

 CREATING TABLES IN SQL SERVER :- 
 ----------------------------------------------------

 CREATE TABLE <TABNAME>
 (
    COLNAME     DATATYPE(SIZE),
    COLNAME     DATATYPE(SIZE),
    -----------------------------------
  ) 

 Rules :- 
 -----------

 1    tabname should start with alphabet
 2    tabname should not contains spaces & special chars but allows _ , $ , #
 3    tabname can be upto 128 chars
 4    table can have 1024 columns 
 5    no of rows unlimited 

 
  ex  :-   123emp        invalid
             emp 123      invalid
             emp*123      invalid
             emp_123     valid
             
Example :- 

=> create table with following structure ?

     EMP
     EMPID     ENAME     JOB    SAL    HIREDATE      DNO

     CREATE TABLE EMP
     (
          EMPID      	 SMALLINT ,
          ENAME    	 VARCHAR(10),
          JOB           	 VARCHAR(10),
          SAL          	 SMALLMONEY,
          HIREDATE 	 DATE,
          DNO           	 TINYINT
      )

  
 SP_HELP  :-     (   SP  =>   stored procedure)
 -----------------

   => command used to see the structure of the table.

            syn :-      SP_HELP    <tabname>

           ex :-         SP_HELP  EMP

                                EMPID		smallint	 	2
		ENAME		varchar	 	10
		JOB		varchar	 	10
		SAL		smallmoney	4
		HIREDATE	date	 	3
		DNO		tinyint	 	1
                         
   INSERTING DATA INTO TABLE :- 
  --------------------------------------------

  =>  "INSERT"  command is used to insert data (row) into table.
  =>   we can  insert 
 
    1  single row
    2  multiple rows 

  single row :- 
  ---------------

      INSERT INTO <TABNAME>  VALUES(V1,V2,V3,-----)

  Ex :- 

    INSERT INTO EMP VALUES(100,'SACHIN','CLERK',5000,'2023-03-30',10)
    INSERT INTO EMP VALUES(101,'RAVI','ANALYST',8000,GETDATE(),10)
 
 multiple rows :- 
 --------------------

   INSERT INTO EMP VALUES(102,'AJAY','CLERK',4000,'2019-10-05',20) ,
                                                (103,'VIJAY','MANAGER',9000,'2020-05-10',30)

 INSERTING NULLS :-  
 -----------------------------

 => a NULL means blank or empty 
 => it is not equal to 0 or space
 => NULLS can be inserted in two ways 

 method 1 :-  
 --------------

   INSERT INTO EMP  VALUES(104,'KUMAR',NULL,NULL,'2018-04-20',20)

method 2 :- 
----------------

   INSERT INTO EMP(EMPID,ENAME,HIREDATE,DNO)
                     VALUES(105,'SATISH',GETDATE(),30)

   remaining two fields job,sal are filled with nulls

31-mar-23

 Displaying Data :- 
 ------------------------

 => "SELECT"  command is used to display data from table.
 => we can display all rows or specific rows.
 => we can display all columns or specific columns.

  syn :-  SELECT  COLUMNS /  *   FROM TABNAME

              SQL             =    ENGLISH
              QUERIES    =    SENTENCES
              CLAUSES  =     WORDS

   =>  display  employee names and salaries ?

         SELECT    ENAME,SAL   FROM  EMP        

   => display  names,salaries and hiredates ?
 
       SELECT  ENAME,SAL,HIREDATE FROM EMP 

   => display all the data from emp table ?

       SELECT  *  FROM EMP

          *    =>  all columns 

  Operators in sql server :- 
  ---------------------------------

1  Arithmetic Operators  =>  +   -    *     /      %

  10+5  =>   15
  10-5   =>   5
  10*5   =>   50
  10/5  =>   2
  10%5 =>   0

2  Relational Operators   =>     >     >=    <     <=    =     <>  or  !=

    10>5      =>   TRUE 
    10<5      =>   FALSE
    10=5      =>   FALSE
    10<>5    =>   TRUE

 3 Logical Operators  =>    AND     OR     NOT   

 4 Special Operators  =>   BETWEEN
                                         IN
                                         LIKE
                                         IS
                                         ANY
                                         ALL
                                         EXISTS
                                         PIVOT

 5  Set Operators       =>    UNION
                                         UNION ALL
                                         INTERSECT
                                         EXCEPT

WHERE clause :- 
------------------------

 => used to fetch specific row/rows from table based on a condition.

        SELECT COLUMNS
        FROM TABNAME
        WHERE  CONDITION 

 CONDITION :- 
 ------------------

   => condition is a  relational expression

           COLNAME   OP    VALUE

   => OP must be any relational  operator like  >   >=   <    <=   =    <> 
  => if  cond = true  row is selected.
  => if cond = false row is not selected

  Examples :- 
  ----------------

  => display  employee details whose id = 103 ? 

       SELECT  *  FROM  EMP  WHERE  EMPID = 103 

   => display employee details whose name = SATISH ?

       SELECT * FROM EMP  WHERE ENAME='SATISH' 

  => display employees earning more than 5000 ?

       SELECT * FROM EMP WHERE SAL>5000

   => display  employees joined after 2020 ?

      SELECT * FROM EMP WHERE HIREDATE > 2020 => ERROR

      SELECT * FROM EMP WHERE HIREDATE > '2020-12-31'

  => display employees joined before 2020 ?

      SELECT * FROM EMP WHERE  HIREDATE <  '2020-01-01' 

 => employees not working for dept 20 ?
 
     SELECT *  FROM  EMP  WHERE  DNO  <> 20 

 compound condition :- 
 -----------------------------

 => multiple conditions combined with  AND / OR  operators is called
      compound condition.

     WHERE    COND1    AND    COND2            RESULT
                        T		 T		T
	        T                       F                             F
                        F                       T                             F
                        F                       F                             F

     WHERE    COND1   OR     COND2             RESULT
	        T                       T                         T
                        T                       F                         T
                        F                       T                         T
                        F                       F                         F

01-APR-23 

 => display employees working as clerk,manager ? 
 
     SELECT * FROM EMP  
                  WHERE JOB = 'CLERK'  OR JOB='MANAGER' 

 => display employees whose name = sachin,vijay,satish ?
 
     SELECT *
     FROM EMP
     WHERE   ENAME='SACHIN'  OR  ENAME='VIJAY' OR ENAME='SATISH' 

 => display employees working as clerk and working for dept 20 ?
 
      SELECT *
      FROM EMP 
      WHERE  JOB='CLERK'  AND  DNO=20
   
=> display employees working for 10th dept and earning more than 5000 ?

    SELECT *
    FROM EMP
    WHERE  DNO=10   AND   SAL>5000

 => display employees earning more than 5000 and less than 10000 ?

     SELECT *
     FROM EMP
     WHERE SAL>5000     AND   SAL<10000

=> employees joined in 2020 year ?

    SELECT *
    FROM EMP
    WHERE HIREDATE  >= '2020-01-01'
                  AND
                  HIREDATE <= '2020-12-31'

  scenario :- 
  --------------

   STUDENT
   SNO    SNAME    S1     S2     S3
   1          A              80     90     70
   2         B               30     60     50

 CREATE TABLE STUDENT
 (
  SID  INT,
  SNAME VARCHAR(10),
  S1 INT,S2 INT,S3 INT
  )

   INSERT INTO STUDENT VALUES(1,'A',80,90,70),
                                                        (2,'B',30,60,50)

   => display list of students who are passed ?

     SELECT * 
     FROM STUDENT
     WHERE  S1>=35  AND   S2>=35   AND    S3>=35

    => list of students who are failed ?
 
       SELECT *
       FROM STUDENT 
       WHERE  S1<35   OR  S2<35    OR    S3<35

  IN operator :-  
  ------------------

 => use IN operator for comparision with list of values.
 => use IN operator for "=" comparision with multiple values.

       WHERE  COLNAME =  V1,V2,V3,--       =>  INVALID
 
       WHERE COLNAME IN (V1,V2,V3,----)   =>  VALID

 => employees whose id = 100,103,105 ?

      SELECT * 
      FROM EMP
      WHERE EMPID IN (100,103,105) 
 
 => employees not working for dept 10,20  ?
 
     SELECT *
     FROM EMP
     WHERE DEPTNO <> 10,20  => error
        
    SELECT *
    FROM EMP
    WHERE DNO NOT IN (10,20)

 BETWEEN operator :- 
 ----------------------------

 => use BETWEEN operator for range comparision.
 
    ex :-   100 to 500 
              2020 to 2025
              
          WHERE  COLNAME  BETWEEN  V1 AND V2 
 
 => display employees earning between 5000 and 10000 ?

     SELECT * FROM EMP WHERE SAL BETWEEN 5000 AND 10000 

                                                      (SAL>=5000 AND SAL<=10000)

 => employees joined in 2020 ? 

     SELECT * 
     FROM EMP 
     WHERE HIREDATE BETWEEN '2020-01-01' AND '2020-12-31' 

  => not joined in 2020 ?

       WHERE HIREDATE NOT BETWEEN '2020-01-01' AND '2020-12-31' 

  03-apr-23    
 
   Question :- 

   SELECT * FROM EMP WHERE SAL BETWEEN 10000 AND 5000 

   A   ERROR
   B   RETURNS ROWS 
   C  RETURNS NO ROWS
   D  NONE 

   ANS :-  C

   WHERE SAL BETWEEN 5000 AND 10000    (SAL>=5000 AND SAL<=10000)

   WHERE SAL BETWEEN 10000 AND 5000    (SAL>=10000 AND SAL<=5000)

   NOTE :- use BETWEEN operator with lower and upper
                 don't use with upper and lower


 => employees working as clerk,manager and earning between 5000 and 10000
      and joined in 2020 and not working for dept 10,20 ?

      SELECT *
      FROM EMP
      WHERE JOB  IN ('CLERK','MANAGER')
                    AND
                    SAL BETWEEN 5000 AND 10000
                    AND
                    HIREDATE BETWEEN  '2020-01-01' AND '2020-12-31'
                    AND
                    DNO NOT IN (10,20)

=> 

  PRODUCTS
  PRODID    PNAME     PRICE     CATEGORY    BRAND
  
  display  samsung,redmi,realme mobile phones price between 10000 and 20000 ?

     SELECT *
     FROM PRODUCTS
     WHERE  BRAND IN ('SAMSUNG','REDMI','REALME')
                     AND
                    CATEGORY='MOBILE PHONES'
                    AND
                    PRICE BETWEEN 10000 AND 20000

   => 

    CUSTOMERS
    CID    NAME     GENDER     AGE     CITY  

    list of male customers age between 30 and 40 and staying in hyd,blr,mum ?

    SELECT *
    FROM CUSTOMERS
    WHERE GENDER='MALE'
                   AND
                   AGE BETWEEN 30 AND 40
                   AND
                   CITY IN ('HYD','BLR','MUM')

 LIKE operator :- 
 ---------------------

 => use LIIKE operator for pattern comparision

    
       WHERE  COLNAME  LIKE  'PATTERN'
       

 => pattern contains alphabets,digits,special chars and wildcard chars.

   wildcard chars :- 
   -------------------------

      %        => 0 or many chars

      _         => exactly 1 char

 
   => employees name starts with 'S' ?

        SELECT * FROM EMP WHERE ENAME  LIKE  'S%' 

  => employees name ends with 'R' ?

      SELECT * FROM EMP WHERE ENAME  LIKE  '%R'

  => employees name contains 'A" ?

       SELECT * FROM EMP WHERE ENAME  LIKE  '%A%' 

   => where  'A' is the 3rd char in their name ?
 
        SELECT *
        FROM EMP
        WHERE ENAME LIKE  '__ A%' 

  => where 'A' is the 3rd char from last ?

       SELECT *
       FROM EMP
       WHERE  ENAME LIKE  ' %A__'

 Question :- 

  SELECT * FROM EMP WHERE JOB IN ('CLERK','MAN%')

  A  ERROR 
 B  RETURNS CLERK,MANAGER records
 C  RETURNS ONLY CLERK records
 D  NONE


  ANS :- C

  =>  'MAN%'  is not treated as pattern  because operator is not LIKE and it is IN
        
    SELECT * FROM EMP WHERE JOB='CLERK'   OR  JOB  LIKE  'MAN%'  

    ANS :-  B

    => employees joined in oct month ?            YYYY-MM-DD

       SELECT * FROM EMP WHERE HIREDATE LIKE '_____10___'
 
     => employees joined in 2020 year ?

        SELECT * FROM EMP WHERE HIREDATE LIKE '2020%' 

   => employees name starts with 'A','V','S' ?

       SELECT * 
        FROM EMP 
        WHERE  ENAME LIKE  'A%'
                       OR
                       ENAME LIKE 'V%'
                       OR 
                       ENAME LIKE 'S%' 

    SELECT *
    FROM EMP 
    WHERE ENAME  LIKE   '[AVS]%' 

 
    [  ]  =>  use square brackets to specify group of chars in particular position.

   => name starts between 'A' and 'P'  ?

        SELECT *
        FROM EMP
        WHERE  ENAME  LIKE  ' [A-P]%' 

  IS operator :- 
  ------------------

  => use IS operator for NULL comparision

       WHERE  COLNAME IS NULL
       WHERE  COLNAME IS NOT NULL

 => find the employees not earning salary ?

     SELECT *
     FROM EMP
     WHERE SAL  IS  NULL 

 => find the employees earning salary ?

     SELECT *
     FROM EMP
     WHERE SAL IS NOT NULL 

 
 summary :- 

 WHERE  COLNAME  IN  (V1,V2,V3,--)
 WHERE  COLNAME BETWEEN V1 AND V2
 WHERE  COLNAME LIKE 'PATTERN'
 WHERE  COLNAME IS  NULL

ORDER BY clause :- 
----------------------------  

=> used to sort data based on one or more columns either in ascending or in descending order

     SELECT columns
     FROM tabname
     [WHERE cond]
     ORDER BY  colname ASC/DESC ,----------

 => default order is ascending 
 => use DESC for descending order

 => arrange employee list name wise ascending order ?

     SELECT *
     FROM EMP
     ORDER BY ENAME  ASC 

 => arrange employee list sal wise desc order ? 

     SELECT *
     FROM EMP
     ORDER BY SAL DESC 

     NOTE :-  

    =>  in order by  nulls treated low , so in ascending order nulls are displayed
          first and in descending order nulls displayed last.

  => arrange employee list dept wise asc and with in dept hiredate wise asc ?

       SELECT *
       FROM EMP
       ORDER BY  DNO ASC , HIREDATE ASC 

     100	SACHIN	CLERK		5000.00	2023-03-30	10
     101	RAVI	ANALYST		8000.00	2023-03-30	10  
    104	KUMAR	NULL		NULL	2018-04-20	20
    102	AJAY	CLERK		4000.00	2019-10-05	20
    103	VIJAY	MANAGER	9000.00	2020-05-10	30
    105	SATISH	NULL		NULL	2023-03-30	30

 => arrange employee list dept wise asc and with in dept sal wise desc ?

     SELECT *
     FROM EMP 
     ORDER BY  DNO ASC , SAL DESC 

     1   A   3000  20			 5   E   4000 10
     2   B   5000 30			 3   C   2000 10
     3   C   2000 10 =============>	 4   D   6000 20
     4   D   6000 20			 1   A   3000  20
     5   E   4000 10			 2   B   5000 30
     
 => 

  STUDENT
  SNO   SNAME    M     P    C
  1         A             80    70    90
  2         B             60    50    70
  3         C            90     80    70
  4         D            90     70    80

 => arrange student list  avg wise desc , m desc, p  desc  ?

 SELECT *
 FROM STUDENT
 ORDER BY (M+P+C)/3  DESC ,M DESC,P DESC 

3         C            90     80    70
4         D            90     70    80
1         A             80    70    90
2         B             60    50    70

 => to display avg in the output 

 SELECT  * , (M+P+C)/3  AS AVG
 FROM STUDENT
 ORDER BY (M+P+C)/3 DESC,M DESC,P DESC

 
3         C            90     80    70	80
4         D            90     70    80	80
1         A             80    70    90	80
2         B             60    50    70	60

ALIAS :- 
------------

=>  alias means another name 
=>  used to change column heading

        colname/expr   AS   ALIAS 

 => display  employee names and annual salaries ? 
 
    SELECT  ENAME,SAL*12  AS "ANNUAL SAL"  FROM EMP 

    SELECT ENAME,SAL*12 AS [ANNUAL SAL] FROM EMP 

 => display   ENAME  SAL    HRA    DA    TAX    TOTSAL   ?

                   HRA = house rent allowance = 20% on sal
                   DA   =  dearness allowance = 30% on sal
                   TAX =  10% on sal
                   TOTSAL = SAL + HRA + DA - TAX 

     SELECT  ENAME,SAL,
                    SAL*0.2 AS HRA,
                    SAL*0.3 AS DA,
                    SAL*0.1 AS TAX,
                    SAL+(SAL*0.2)+(SAL*0.3)-(SAL*0.1) AS TOTSAL
     FROM EMP 

   05-apr-23 

   DISTINCT clause :- 
   -------------------------

  =>  DISTINCT claus eliminates duplicates from select statement output

             SELECT  DISTINCT col1
                            DISTINCT col1,col2,----

    ex :-  

   1	SELECT DISTINCT DNO FROM EMP

      	10
	20	
	30

   2           SELECT DISTINCT JOB FROM EMP 

                ANALYST
               CLERK
               MANAGER

    TOP clause :- 
    ------------------

    => used to display top n rows from table.

         SELECT   TOP  <n>    COLNAMES / *
         FROM TABNAME
         [WHERE COND]
         [ORDER BY COLNAME ASC/DESC]

 =>  display first 5 rows from emp table ?

      SELECT TOP 5  *
      FROM EMP 
      
 => display top 5 highest paid employees ?
 
      SELECT TOP 5 *
      FROM EMP
      ORDER BY SAL DESC 

 => display top 5 employees based on experience ?

      SELECT TOP 5 *
      FROM EMP 
      ORDER BY HIREDATE ASC 

 => display top 5 max salaries ?

    SELECT DISTINCT TOP 5 SAL
    FROM EMP 
   ORDER BY SAL DESC

  DML  commands :-   (Data Manipulation Lang)
  --------------------------

 INSERT
 UPDATE
 DELETE
 MERGE 

=> all dml commands acts on table data.
=> by default all dml commands are auto committed.
=> to stop auto commit execute the following command

         SET IMPLICIT_TRANSACTIONS ON 

 => to save the operation execute COMMIT.
 => to cancel the operation execute ROLLBACK.

 UPDATE command :- 
 ---------------------------

 => used to modify the table data.
 => we can update all rows or specific rows
 => we can update single column or multiple columns

  syn :-  UPDATE <tabname>
             SET colname = value , colname = value ,------------
             [WHERE cond] 

  ex :- 

 => update all employees comm with 500 ?

      UPDATE emp SET comm = 500 

 => update employees comm with 500 whose comm = null ?
 
      UPDATE emp SET comm = 500 WHERE comm IS NULL 

 => update employees comm with null whose comm <> null ?

      UPDATE emp SET comm = NULL  WHERE comm IS NOT NULL 

         NULL assignment   =
         NULL comparision  IS
 
 => update sal with 2000 and comm with 500 whose empno = 7369 ?

     UPDATE emp SET sal = 2000 , comm = 500  WHERE empno = 7369

 => increment sal by 20% and comm by 10% those working as salesman
      and joined in 1981 year ?

      UPDATE emp 
      SET sal = sal + (sal*0.2 ) , comm = comm + (comm*0.1)
      WHERE job='SALESMAN'
                    AND
                    hiredate LIKE '1981%' 


06-apr-23

PRODUCTS
prodid   pname    price    category     brand

=> increase  all  samsung,redmi,realme   mobile phones , tvs and smart watches price by 10%

 UPDATE PRODUCTS
 SET PRICE = PRICE + (PRICE *0.1)
 WHERE BRAND IN ('SAMSUNG','REDMI','REALME')
               AND
               CATEGORY IN ('MOBILE PHONES','TV','SMART WATCH')

DELETE command :- 
---------------------------

 =>  command used to delete row/rows from table
 =>  we can delete all rows or specific rows
 
   syn :-    DELETE  FROM   TABNAME  [WHERE COND] 

Ex :- 
------

  =>   delete employees joined in 1981 year ?
 
        DELETE FROM EMP WHERE HIREDATE  LIKE '1981%' 

  =>  delete employees working for 30th dept and working as salesman ?

        DELETE FROM EMP WHERE DEPTNO = 30  AND JOB = 'SALESMAN' 

   
DDL commands :-  (DATA DEFINITION LANG)
----------------------

  => all DDL commands acts on table structure (columns,datatype and size)

   CREATE
   ALTER
   DROP
   TRUNCATE

  ALTER command :- 
  --------------------------

  => command used to modify the table structure
  => using ALTER command we can

   1   add columns
   2   drop columns
   3   modify a column
               changing datatype
               changing size

  Adding columns :- 
 ------------------------

  syn :- 

    ALTER TABLE <TABNAME>
          ADD   COLNAME  DATATYPE(SIZE)  , ---------

  Ex :- 

  => add column gender to emp table ?

      ALTER TABLE EMP
              ADD  GENDER  CHAR(1)

     after adding by default the new column is filled with nulls , to insert
     data into the new column use update command.

     UPDATE EMP SET GENDER='M' WHERE EMPNO = 7369 

 Droping column :- 
 -----------------------

    ALTER TABLE <TABNAME>
         DROP COLUMN  COL1,COL2,----

 => drop column gender from emp table ?

    ALTER TABLE EMP
            DROP COLUMN GENDER 

Modifying a column :- 
-----------------------------

   ALTER TABLE <TABNAME>
       ALTER  COLUMN  <COLNAME>  DATATYPE(SIZE)
 
Ex :- 

 => change the datatype of sal to money ?
 
     ALTER TABLE EMP
            ALTER COLUMN  SAL  MONEY

 => increase the size of ename to 20 ?

  ALTER TABLE EMP
       ALTER COLUMN ENAME  VARCHAR(20) 


  ALTER TABLE EMP
       ALTER COLUMN ENAME  VARCHAR(5) 

                               => ERROR => because some names contains
                                                      more than 5 chars 

  DROP command :- 
  ---------------------------

  => command used to drop table from database.
  => drops table structure along with data.

  syn :-  DROP TABLE  <TABNAME>

  ex  :-   DROP TABLE EMP 

 TRUNCATE command :- 
 ---------------------------------

  => deletes all the data from table but keeps structure.
  => will empty the table.
  => releases memory allocated for table 

   syn :-   TRUNCATE TABLE  <TABNAME>

   ex  :-    TRUNCATE TABLE STUDENT 

 DROP VS  DELETE VS TRUNCATE  :- 
 -----------------------------------------------------

      DROP                                  DELETE/TRUNCATE

    drops structure                      deletes only data but not structure
     with data 

 DELETE VS TRUNCATE :- 
 ------------------------------------

                  DELETE                                          TRUNCATE

 1               DML command                                DDL  command

 2               can delete all rows                           can delete only all rows
                  and specific rows                             but cannot delete specific rows

 3               where cond can be                           where cond cannot be
                  used with delete                               used with truncate

 4              deletes row-by-row                            deletes all rows at a time

 5              slower                                               faster

 6              will not release memory                    releases memory 

 7              will not reset identity                         will reset identitty      

 
07-apr-23

 SP_RENAME :-    (SP => stored procedure)
 --------------------

 =>  used to change table name and column name

         SP_RENAME   ' OLD NAME ' , ' NEW NAME ' 

  Ex :- rename table emp to employees ?

         SP_RENAME  'EMP', 'EMPLOYEES' 

          rename column comm to bonus in employees table ?

          SP_RENAME  'EMPLOYEES.COMM','BONUS'

 Built-in Functions in SQL SERVER :- 
 ------------------------------------------------

 => a function accepts some input performs some calculation and
      returns one value.
 
 Types of functions :- 
 -------------------------

  1  DATE
  2  STRING
  3  NUMERIC
  4  CONVERSION
  5  SPECIAL
  6  ANALYTICAL
  7  AGGREGATE

  DATE functions :- 
  ------------------------

  GETDATE() :- 
  -----------------

   => returns current date & time

      SELECT GETDATE()  => 2023-04-07 16:34:34.510
                                             ---------------  ----------  -----
                                                  DATE       TIME     MS

 DATEPART() :- 
 --------------------

  => used to extract part of the date.

             DATEPART(interval,date)

   ex :- 

             SELECT  DATEPART(YY,GETDATE())    =>   2023
                                               MM                       =>   04
                                               DD                        =>   07
                                               DW                       =>   06 (DAY OF THE WEEK)

                                                                                   1  SUNDAY
                                                                                   2  MONDAY

                                                                                   7  SATURDAY
                                               Q                          =>   2  (QUARTER)  
                                              
                                                                                  JAN-MAR    1
                                                                                  APR-JUN     2
                                                                                  JUL-SEP     3
                                                                                  OCT-DEC    4

                                               HH                        =>  hour part
                                               MI                         =>  minutes
                                               SS                        =>  seconds
                                               DAYOFYEAR        =>  97
                                               WW                      =>  14

 => employees joined in 1980,1983,1985 ?

     SELECT *
     FROM EMP
     WHERE HIREDATE LIKE '1980%'
                    OR
	   HIREDATE LIKE '1983%'
	    OR
	   HIREDATE LIKE '1985%'

    SELECT *
    FROM EMP
    WHERE DATEPART(YY,HIREDATE)   IN (1980,1983,1985)

 => employees joined in leap year ?

     condition :-     year%4=0

     SELECT *
     FROM EMP
     WHERE  DATEPART(yy,HIREDATE)%4=0

 => employees joined between  jan and apr ?

     SELECT *
     FROM EMP
     WHERE  DATEPART(mm,HIRERDATE)  BETWEEN 1 AND 4 

=> employees joined on sunday ?

     SELECT *
     FROM EMP
     WHERE  DATEPART(DW,HIREDATE) = 1 

=> employees joined in 2nd quarter of 1981 year ?
 
    SELECT *
    FROM EMP
    WHERE DATEPART(yy,HIREDATE) = 1981
                  AND
                  DATEPART(q,HIREDATE) = 2 

  DATENAME() :- 
  ---------------------

  => similar to datepart used to extract part of the date.
 
  		   MM		DW

        DATEPART         4 		6

  
       DATENAME        APRIL		FRIDAY

 
   => display   ENAME        DAY OF THE WEEK   ? 

                      
     SELECT  ENAME,DATENAME(DW,HIREDATE) AS DAY
     FROM EMP 

   => write a query to display on which day india got independence ?

        SELECT DATENAME(DW,'1947-08-15')   =>  Friday

  DATEDIFF() :- 
  --------------------

 => used to calculate difference between two dates 

          DATEDIFF(interval,start date,end date)

   ex :-  

     SELECT  DATEDIFF(yy,'2022-04-07',getdate())    =>  1
     SELECT  DATEDIFF(mm,'2022-04-07',getdate())  =>  12
     SELECT  DATEDIFF(dd,'2022-04-07',getdate())    =>  365
      
  => display  ENAME    EXPERIENCE  in years ?

      SELECT ENAME,
                    DATEDIFF(yy,HIREDATE,GETDATE()) as EXPERIENCE
     FROM EMP 

08-APR-23

   => display  ENAME    EXPERIENCE  ?
                                     M YEARS N MONTHS 

          experience = 40 months = 3 YEARS 4 MONTHS 

          years    =  months/12 = 40/12  = 3     years
          months =  months%12 = 40%12 = 4  months

         SELECT ENAME,
                       DATEDIFF(MM,HIREDATE,GETDATE())/12 AS YEARS,
                       DATEDIFF(MM,HIREDATE,GETDATE())%12 AS MONTH 
         FROM EMP 

  FORMAT() :- 
  ----------------

  => used to display dates in different formats 

          FORMAT(DATE,'FORMAT')

 ex :- 

1   SELECT FORMAT(GETDATE(),'MM/dd/yyyy')   =>  04/08/2023

2   SELECT FORMAT(GETDATE(),'MM/dd/yyyy hh:mm:ss') => 04/08/2023 04:38:20

=> display  ENAME    HIREDATE    ?
     display hriedates in DD-MM-YYYY ?

    SELECT ENAME,
                  FORMAT(HIREDATE,'dd-MM-yyyy') AS HIREDATE
    FROM EMP 

 scenario :- 
 --------------

  INSERT INTO EMP(EMPNO,ENAME,JOB,SAL,HIREDATE)
                 VALUES(100,'ABC','CLERK',4000,GETDATE())

 => display list of employees joined today ?

     SELECT * 
     FROM EMP 
     WHERE HIREDATE =  GETDATE()     =>  NO ROWS 
 
                   2023-04-08  =  2023-04-08 16:54:20.123

   "="  comparision with GETDATE() always fails  because date compared
    with date & time.  To overcome this problem use FORMAT function

  SELECT *
  FROM EMP
  WHERE  HIREDATE = FORMAT(GETDATE(),'yyyy-MM-dd')

 DATEADD() :- 
 -----------------

 => used to add days,months,years to a date 
 => can also be used to subtract

      DATEADD(interval,number,date)

 ex :-  

   1    SELECT  DATEADD(DD,10,GETDATE())   => 2023-04-18
   2   SELECT   DATEADD(MM,6,GETDATE())   => 2023-10-8
   3   SELECT   DATEADD(MM,-2,GETDATE())  => 2023-02-08

 scenario :- 
 --------------

 GOLD_RATES
 DATEID		RATE
 2020-01-01	?
 2020-01-02	?

 2023-04-08	?

 
1  display today's gold rate ?
2  display yesterday's gold rate ?
3  display last month same day gold rate ?
4  display last year same day gold rate ?

 
1  SELECT  RATE 
    FROM GOLD_RATES
    WHERE DATEID =  FORMAT(GETDATE(),'yyyy-MM-dd')

 2  SELECT  RATE 
     FROM GOLD_RATES
     WHERE DATEID = DATEADD(DD,-1,FORMAT(GETDATE(),'yyyy-MM-dd'))

3   SELECT  RATE 
     FROM GOLD_RATES
     WHERE DATEID = DATEADD(MM,-1,FORMAT(GETDATE(),'yyyy-MM-dd'))

 4  SELECT  RATE 
     FROM GOLD_RATES
     WHERE DATEID = DATEADD(YY,-1,FORMAT(GETDATE(),'yyyy-MM-dd'))

 5  display last 1 month gold rates  ?

    SELECT *
    FROM GOLD_RATES
    WHERE DATEID BETWEEN  DATEADD(MM,-1,GETDATE())  AND GETDATE()

 EOMONTH() :-  
 -------------------

 => returns last day of the month 

          EOMONTH(DATE,NUMBER)

  1   SELECT EOMONTH(GETDATE(),0)   =>   2023-04-30

  2   SELECT EOMONTH(GETDATE(),1)   =>   2023-05-31

  3   SELECT EOMONTH(GETDATE(),-1)   =>  2023-03-31 

 
Questions :- 
---------------

 1  display  current month first day ?
 2  display  first day of the next month ? 
 3  display  first day of the current year ?
 4  display last day of the current year ?

STRING functions :- 
--------------------------

UPPER() :- 
-------------

 => converts string to uppercase 

    syn :-  UPPER(string) 

 SELECT UPPER('hello')   =>  HELLO

 LOWER() :- 
 --------------

 => converts string to lowercase 

    syn :- LOWER(string)

  SELECT  LOWER('HELLO')   => hello 

=> display   ENAME   SAL  ?  display names in lowercase ?
 
     SELECT  LOWER(ENAME) AS ENAME,SAL FROM EMP 

=> convert names to lowercase in table ?

    UPDATE EMP SET ENAME = LOWER(ENAME) 

10-apr-23 :- 
---------------

 LEN() :- 
 ----------

 =>  returns string length i.e. no of chars 

          LEN(string) 

   SELECT LEN('hello')      => 5  
   SELECT LEN('hello welcome')   =>  13

=> employees    name contains 5 chars ?

     SELECT *
     FROM EMP
     WHERE  ENAME LIKE  '_____' 

    SELECT *
    FROM EMP
    WHERE LEN(ENAME) = 5 

 => arrange employee list len of ename wise asc order ? 

     SELECT *
     FROM EMP
    ORDER BY LEN(ENAME) ASC 

 LEFT() :- 
 ------------

 => used to extract part of the string.

             LEFT(string,length)

      SELECT LEFT('hello welcome',5)   =>   hello

   =>employees name starts with 's' ?

      SELECT * FROM EMP WHERE  ENAME LIKE 's%'

      SELECT * FROM EMP WHERE LEFT(ENAME,1)='S'
 
 RIGHT() :- 
 ---------------

  => returns characters starting from right side .

                 RIGHT(string,len) 

     SELECT RIGHT('hello welcome',4)   =>   come

   => employees name ends with 's' ? 

      SELECT * FROM EMP WHERE ENAME LIKE '%s' 

      SELECT * FROM EMP WHERE RIGHT(ENAME,1)='s'
  
   => employees name starts and ends with same char ?

         SELECT * FROM EMP WHERE ENAME LIKE  'a%a'
                                                            OR
                                                            ENAME LIKE 'b%b'
                                                            OR
 
        SELECT * FROM EMP WHERE LEFT(ENAME,1) = RIGHT(ENAME,1) 

    
  scenario :- 
  --------------

   =>  generate emailids for employees ?

         empno        ename            emailid
         7369          smith               smi736@tcs.com
         7499          allen                all749@tcs.com

        concatenation operator  =>  + 

                               'a' + 'b'   =>   ab
                             
       SELECT empno,ename,
                      LEFT(ename,3) +  LEFT(empno,3) + '@tcs.com'  as emailid
       FROM emp 

      => store emailids in db ?

       step 1 :- add emailid column to emp table 

         ALTER TABLE EMP
                  ADD    EMAILID  VARCHAR(30) 

      step 2 :-  update the column with emailids 

     UPDATE EMP 
     SET EMAILID = LEFT(ename,3) + LEFT(empno,3) + '@tcs.com'

   SUBSTRING() :- 
   ----------------------

   => used to extract part of the string starting from specific position

               SUBSTRING(string,start,len)

 
     SELECT SUBSTRING('HELLO WELCOME',7,4)   =>  WELC

     
   REPLICATE() :- 
   ----------------------

   => used to repeat char for given no of times 

         REPLICATE(char,len)

   SELECT REPLICATE('*',10)   =>  **********

   => display  ENAME    SAL    ?
                                      
                                     1000.00  =>   ********

       SELECT ENAME,REPLICATE('*',LEN(SAL)) AS SAL FROM EMP 

 
scenario :- 
--------------

   ACCOUNTS
   ACCNO                      BAL
   123456789623          10000

   your a/c no  XXXX9623  debited  -------  ? 

   
 CREATE TABLE ACCOUNTS
 (
   ACCNO  BIGINT,
    BAL  MONEY
  )
  
  INSERT INTO ACCOUNTS VALUES(12345678963,10000)

  SELECT REPLICATE('X',4)  + RIGHT(ACCNO,4) FROM ACCOUNTS 
   
 REPLACE() :- 
 ------------------

 => used to replace one string with another string

                  REPLACE(str1,str2,str3) 

      in str1,  str2 replaced with str3 

  
   SELECT REPLACE('hello','ell','abc')      =>    habco
   
  SELECT REPLACE('hello','l','abc')         =>    heabcabco

  SELECT REPLACE('hello','elo','abc')      =>    hello

  SELECT REPLACE('hello','ell','')            =>     ho

=> remove   '@' from '@@he@@ll@@o@@'   ?

      output :- hello

    SELECT  REPLACE('@@he@@ll@@o@@','@','')    =>   hello

TRANSLATE() :- 
---------------------

 => used to translate one char to another char

                TRANSLATE(str1,str2,str3)

    SELECT TRANSLATE('hello','elo','abc')         =>   habbc 

                        e  => a
                        l   => b
                        o  => c 

   SELECT TRANSLATE('hello','elo','')             => ERROR


11-apr-23

  NOTE :-   translate function can be used to encrypt data i.e. converting plain text to 
  cipher text i.e. the text one cannot understand

 example :- 

 => display ENAME  SAL  ?   encrypt salaries ?
 

   SELECT  ENAME,
                   TRANSLATE(SAL,'0123456789.' , '$kT*g@U%^#&')  AS SAL
   FROM EMP 

 
        JONES     2975.00   =>  T#%@&$$


=>   remove all special chars from  '@#he*&ll$%o^#'  ?

           output :-  hello 
 

 step 1 :-   translate all the special chars to one special char

  SELECT  TRANSLATE('@#he*&ll$%o^#' ,'@#*&$%^#','@@@@@@@@')
   
  output :- @@he@@ll@@o@@

 step 2 :-  replace '@' with null

 SELECT
     REPLACE(TRANSLATE('@#he*&ll$%o^#' ,'@#*&$%^#','@@@@@@@@'),'@','')

 
CHARINDEX() :- 
---------------------

 => returns position of a character in a string.

    CHARINDEX(char,string,[start]) 

  SELECT CHARINDEX('O','HELLO WELCOME')   =>   5
  SELECT CHARINDEX(' ','HELLO WELCOME')     =>   6
  SELECT CHARINDEX('X','HELLO WELCOME')   =>   0
  SELECT CHARINDEX('O','HELLO WELCOME',6)  => 11
  SELECT CHARINDEX('L','HELLO WELCOME',5)   => 9
  
 Assignment :- 
 -----------------

 CUST
 CID	NAME
 10	SACHIN TENDULKAR
 11	VIRAT KOHLI
 
 output :- 

  CID	FNAME	LNAME
  10	SACHIN	TENDULKAR

Numeric Functions :- 
---------------------------

ABS() :- returns absolute value

  SELECT ABS(-10)   =>    10 
  SELECT ABS(10)    =>    10

POWER() :-  used to calculate power

   SELECT POWER(3,2)  => 9

SQRT() :- returns square root of a number

  SELECT SQRT(16) => 4 

SIGN() :-  used to find whether given number is positive or negative

  SELECT SIGN(100)  => 1
  SELECT SIGN(-100) => -1
  SELECT SIGN(100-100) => 0

Rounding numbers :- 
---------------------------- 
 
ROUND
CEILING
FLOOR

      38.456789   => 38
                               38.46
                               38.4568

ROUND :- 
--------------

 => rounds number to integer or to decimal places 

     ROUND(number,decimal places)

  SELECT ROUND(38.456789,0)   => 38

   38----------------------------38.5--------------------------------39

   number >= avg  => rounded to highest
   number < avg    =>  rounded to lowest 

    SELECT ROUND(38.556789,0)   => 39

   SELECT ROUND(38.456789,2)   =>  38.46

   SELECT ROUND(38.453789,2)   =>  38.45

   SELECT ROUND(386,-2)            =>  400
  
    
      300------------------350-----------------------400

     SELECT ROUND(386,-1)          =>   390

     380-------------------385---------------------390

      SELECT ROUND(586,-3)         =>   1000
 
     0------------------500---------------------1000

    
  display  ename  sal ? round sal to hundreds ?

  SELECT ENAME,ROUND(SAL,-2) AS SAL FROM EMP   

      
 SELECT ROUND(4567,-1),ROUND(4567,-2),ROUND(4567,-3) 

  O/P :-  4570            4600                5000

 CEILING() :- 
 --------------

  => rounds number always to highest

            CEILING(number)

    SELECT CEILING(3.1)    =>    4  
 
 FLOOR() :- 
 ---------------

 => rounds number always to lowest

         FLOOR(number) 

  SELECT FLOOR(3.9)    =>    3 

conversion functions :- 
-----------------------------

=> these functions are used to convert one datatype to another datatype

  1 CAST
  2 CONVERT 

 
 CAST :- 
 -----------
                     CAST(expr AS  target-type)

   SELECT  CAST(10.5  AS INT)  =>   10 
  
 => display  smith  earns  1000
                   allen   earns  1600  ? 
 
      SELECT ename  + ' earns ' +  sal  FROM emp    => ERROR

     SELECT ename  + ' earns ' +  CAST(sal AS VARCHAR)
     FROM emp 

  => display  smith joined on 1980-12-17 as clerk ? 
                    
       SELECT ename + ' joined on ' + 
	              CAST(hiredate AS VARCHAR) + ' as ' + job
       FROM emp 

12-apr-23

 CONVERT() :- 
 -------------------

               CONVERT(TARGET-TYPE,SOURCE-VALUE)

    SELECT CONVERT(INT,10.5) 


 => diff b/w cast & convert ? 

    1   using convert function we can display dates in different formats but not possible using
         cast function

    2 using convert function we can display money in different formats but not possible using
      cast function 

    Displaying dates in different formats :- 
   --------------------------------------------------
 
         CONVERT(VARCHAR,DATE,STYLE NUMBER)

 EX :- 

     SELECT  CONVERT(VARCHAR,GETDATE(),101)   =>   04/12/2023
                                                                             102    =>   2023.04.12
                                                                             103    =>   12/04/2023
       
                                                                             112    =>   20230412
                                      
                                                                             114   =>    16:30:13:880

  
   display  ENAME    HIREDATE   ?  display hiredates in DD.MM.YYYY format ?

   
   SELECT  ENAME,CONVERT(VARCHAR,HIREDATE,104) AS HIREDATE FROM EMP 
                  
     
 Money Styles :-  
 ---------------------

 0  =>  2 digits after decimal                                 (1000.00)
 1  =>  displays number with thousand seperator  (1,000.00)
 2  =>  4 digits after decimal                                  (1000.0000)

 display  ENAME  SAL  ?  display salaries with thousand seperator ?
 
 SELECT  ENAME,CONVERT(VARCHAR,SAL,1) AS SAL FROM EMP 

 Special functions :- 
 --------------------------

  ISNULL() :-  
  ----------------

  => used to convert null values 

               ISNULL(arg1,arg2)

         if arg1 = null returns arg2
         if arg1 <> null returns arg1 only

      SELECT ISNULL(100,200)     =>    100
      SELECT ISNULL(NULL,200)  =>    200

 => display  ENAME  SAL    COMM   TOTSAL   ?

             TOTSAL = SAL + COMM 
 
      SELECT ENAME,SAL,COMM, SAL+COMM AS TOTSAL FROM EMP 
 
      smith    1000      500         1500
      jones    2975      NULL       NULL

       SELECT ENAME,SAL,COMM, SAL+ISNULL(COMM,0) AS TOTSAL FROM EMP 
  
 	 smith    1000      500         1500
     	 jones    2975      NULL      2975

   => display   ENAME  SAL   COMM  ?   if COMM = NULL display  NO COMM ?

 	SELECT ENAME,SAL,
     	        ISNULL(CAST(COMM AS VARCHAR),'NO COMM') AS COMM
 	FROM EMP  
   
 Analytical Functions :- 
-----------------------------

 RANK & DENSE_RANK :- 
 ----------------------------------

 =>  both functions  are used to find ranks
 =>  ranking is always based on some field
 =>  for rank functions data must be sorted 

    syn :-   RANK() OVER  (ORDER BY  COLNME  ASC/DESC , --------)
                DENSE_RANK() OVER (ORDER BY COLNAME ASC/DESC,-----)

  =>  display ranks of the employees based on sal and highest paid employee should get
        1st rank ?

       SELECT  ENAME,SAL,
                       RANK() OVER (ORDER BY  SAL DESC) AS RNK
       FROM EMP 
        
         	 
     difference between  rank & dense_rank  functions ? 
   
    1    rank function generates gaps but dense_rank will not generate gaps.
 
    2    rank function ranks may not be in sequence but in dense_rank
          ranks are always in sequence.

	        SAL		RANK		DENSE_RANK
 	        5000		1		1
                        4000		2		2
                        3000		3		3
                        3000		3		3
                        3000		3		3
                        2000		6		4
                        2000		6		4
                        1000		8		5

 =>  display ranks of the employees based on sal , if salaries are same 
       then ranking should be based on hiredate ?

       SELECT  ename,hiredate,sal,
                      DENSE_RANK() OVER (ORDER BY sal DESC,
                                                                               hiredate ASC) as rnk
       FROM emp 

 Question :- 
 -----------------

  STUDENT
  SNO  SNAME  M   P   C
  1       A             80  90  70
  2       B             60  50  70
  3       C             90  80  70
  4       D             90  70  80

 => find the ranks of the students based on avg desc,m desc,p desc ?

13-arp-23

  PARTITION BY clause :- 
  --------------------------------

  => used to find ranks with in group , for example to find ranks with in dept 
       first we need to divide the table dept wise by using  partition by clause
       and apply dense_rank function on each dept.

    SELECT  ename,sal,deptno,
             dense_rank() over (partition by deptno
                                          order by sal desc) as rnk
    FROM emp 

      	king	5000.00	10	1
	clark	2450.00	10	2
	miller	1300.00	10	3

	ford	3000.00	20	1
	scott	3000.00	20	1
	jones	2975.00	20	2
	adams	1100.00	20	3
	smith	1000.00	20	4
  
 ROW_NUMBER() :- 
 --------------------------

 =>  returns record number
 => row_number is also based on a column
 => for row_number data must be sorted 

     ROW_NUMBER() OVER (ORDER BY COLNAME ASC/DESC)

 Ex :- 

    SELECT empno,ename,sal,
           row_number() over (order by empno asc) as rno
   FROM emp 

     	7369	smith	1000.00	1
	7499	allen	1600.00	2
	7521	ward	1250.00	3
	7566	jones	2975.00	4
	7654	martin	1250.00	5

RANK VS DENSE_RANK VS ROW_NUMBER :- 
----------------------------------------------------------------

    SAL		RANK	DENSE_RANK	ROW_NUMBER

    5000		1	1		1	
    4000		2	2		2
    3000		3	3		3
    3000		3	3		4
    3000		3	3		5
    2000		6	4		6
    2000		6	4		7
    1000		8	5		8		

 AGGREGATE functions :-  
 ----------------------------------

 =>  these functions process groups of rows and returns one value.

  MAX() :- 
  -----------

 => returns maximum value

     MAX(arg) 

1   SELECT MAX(SAL) FROM EMP    =>  5000

2   SELECT MAX(HIREDATE) FROM EMP  => 1983-01-12

MIN() :- 
---------

  => returns minimum value

   MIN(arg) 

  SELECT MIN(sal) FROM emp  =>  800

 SUM() :- 
 ------------

 => returns total

  SUM(arg) 

  SELECT SUM(sal) FROM emp   => 29225

 => round the total sal to thousands ?

 SELECT ROUND(SUM(sal),-3)  FROM emp  => 29000
     
 29000----------------29500--------------------30000

 => after rounding display total sal with thousand seperator ?
 
     SELECT CONVERT(VARCHAR,ROUND(SUM(sal),-3) ,1) 
     FROM emp

    O/P :-  29,000.00

 => display total sal paid to managers ?

     SELECT SUM(sal)
     FROM emp 
     WHERE job='MANAGER' 

  O/P :- 8275

 AVG() :- 
 -----------

 => returns average value

  AVG(arg) 

 1  SELECT AVG(sal) FROM emp   =>   2087.50

 2  SELECT FLOOR(AVG(sal))  FROM emp  => 2087.00
 
COUNT(*) :- 
----------------

 => returns no of rows in a table

     SELECT COUNT(*) FROM emp   =>  14
 
 => how many employees joined in 1981 year ?

     SELECT COUNT(*) FROM emp 
                    WHERE DATEPART(YY,HIREDATE) = 1981 

 => how many employees joined on  sunday ?

      SELECT COUNT(*) 
      FROM emp 
     WHERE DATEPART(DW,HIREDATE) = 1 

 NOTE :- aggregate functions are not allowed in where clause and they
 are allowed only in select,having clauses

 
  SELECT ename
  FROM emp
  WHERE  sal = MAX(sal)   => ERROR 

 WHERE COUNT(*)=3        => ERROR 

 
 date       :-   getdate(),datepart,datename,datediff,dateadd,eomonth
 string     :- upper,lower,len,left,right,substring,replicate,replace,translate,charindex
 numeric  :-  power,sqrt,abs,sign,round,ceiling,floor
 conversion :-  cast,convert
 special     :-  isnull
 analytical :-  rank,dense_rank,row_number
 aggregate :- max,min,sum,avg,count(*)


 CUST
 CID	NAME
 10	sachin tendulkar
 11	virat kohli

 o/p :- 

  CID	FNAME	LNAME
  
  first name :-     SUBSTRING(string,start,length)

         SUBSTRING(NAME,1, CHARINDEX(' ',NAME)-1)

  last name :-       
 
         SUBSTRING(NAME,CHARINDEX(' ',NAME)+1,LEN(NAME))
 
  SELECT CID,
   SUBSTRING(NAME,1, CHARINDEX(' ',NAME)-1) AS FNAME,
   SUBSTRING(NAME,CHARINDEX(' ',NAME)+1,LEN(NAME)) AS LNAME
  FROM CUST 

14-apr-23

 GROUP BY clause :-  
 ---------------------------   
 
  => group by clause is used to group rows based  one or more columns
       to calculate min,max,sum,avg,count for each group. For example
       to calculate dept wise total sal then first group the records based on
       dept  and calculate total sal for each dept.

        EMP
        EMPNO ENAME  SAL    DNO
        1            A            3000   10
        2           B             4000   20      GROUP BY        10      9000
        3           C            5000   30     =========>       20      7000
        4           D            6000  10                                  30      5000
        5          E             3000   20
       
          detailed data                                                     summarized data 

    
   => GROUP BY clause converts detailed into summarized data which is useful for analysis

    syn :- 

     SELECT columns
     FROM tabname
    [WHERE cond] 
    GROUP BY col1,col2,------
    [HAVING cond]
    [ORDER BY col1,col2,----]

 execution :- 

  FROM
  WHERE
  GROUP BY
  HAVING
  SELECT
  ORDER BY 

 => display dept wise total salary ?

	SELECT deptno,SUM(sal) as totsal
	FROM emp 
	GROUP BY deptno 

FROM emp :-
------------------
       
       EMP
        EMPNO ENAME  SAL    DEPTNO
        1            A            3000   10
        2           B             4000   20      
        3           C            5000    30     
        4           D            6000    10                               
        5          E             3000     20

 GROUP BY deptno :- 
 ----------------------------

   10
	1	A	3000
	4	D	6000

  20
	2	B	4000
	5	E	3000

  30
	3	C	5000

SELECT deptno,SUM(sal) as totsal :- 
------------------------------------------------

  10	9000
  20	7000
  30	5000

 => display job wise no of employees ?

     SELECT JOB,COUNT(*) AS CNT
    FROM EMP 
    GROUP BY JOB 
  
 => display no of employees joined in each year ?

    SELECT  DATEPART(YY,HIREDATE) AS YEAR,COUNT(*) AS CNT
    FROM EMP 
    GROUP BY DATEPART(YY,HIREDATE)
 
    SELECT  DATEPART(YY,HIREDATE) AS YEAR,COUNT(*) AS CNT
    FROM EMP 
    GROUP BY YEAR    => INVALID
    ORDER BY YEAR DESC  => VALID
 
     NOTE :-  

    1  alias cannot be used in  group by clause because  group by clause is executed 
        before select 

   2   alias can be used in order by clause because order by clause is executed after select 

 => display day wise no of employees joined ?

   SELECT  DATENAME(DW,HIREDATE) AS DAY,COUNT(*) AS CNT
   FROM EMP 
   GROUP BY DATENAME(DW,HIREDATE)
 
 =>  display month wise no of employees joined in the year 1981 ?

        SELECT DATENAME(MM,HIREDATE) AS MONTH,COUNT(*)
        FROM EMP 
       WHERE DATEPART(YY,HIREDATE)=1981
       GROUP BY DATENAME(MM,HIREDATE) 

=> find the depts having more than 3 employees ?

    SELECT DEPTNO,COUNT(*) AS CNT
    FROM EMP 
    WHERE COUNT(*) > 3 
    GROUP BY DEPTNO      => ERROR

    sql server cannot calculate dept wise count before group by and it can calculate
    only after group by , so apply the condition COUNT(*) > 3 after group by  using
    having clause.

    SELECT DEPTNO,COUNT(*) AS CNT
    FROM EMP  
    GROUP BY DEPTNO
    HAVING COUNT(*) > 3 

   WHERE VS HAVING clause :- 
  -----------------------------------------

                   WHERE                                        HAVING 

 1    selects specific rows                                  selects specific group
 
 2    conditions applied                                      conditions applied
       before group by                                         after group by 

 3    use where clause if                                   use having clause
       cond doesn't contain                                 if cond contains 
       aggregate function                                    aggregate function

 
=>  find southern states having more than 5cr population ?

 PERSONS
 NAME  AGE  GENDER    ADDR   CITY   STATE 

 SELECT STATE,COUNT(*)
 FROM PERSONS
 WHERE state IN ('AP','TS','KA','TN','KL')
 GROUP BY STATE 
 HAVING COUNT(*) > 50000000

15-apr-23

 =>  display dept wise and with in dept job wise total salary ?

       SELECT deptno,job,SUM(sal) as totsal
       FROM emp 
      GROUP BY deptno,job 
      ORDER BY deptno ASC 

 
 	10    	CLERK     	1300
         		MANAGER 	2450
         		PRESIDENT	5000

 	20    	ANALYST		6000
        		 CLERK		1100
       		 MANAGER	2975
 
 	30   	SALESMAN	4100
  
 	
  =>  display year wise and with in year quarter wise no of employees joined ?

      SELECT  DATEPART(yy,hiredate) as year,
                      DATEPART(q,hiredate) as qrt,
	      COUNT(*) as cnt
     FROM emp 
     GROUP BY DATEPART(yy,hiredate),DATEPART(q,hiredate)
     ORDER BY year ASC 

  ROLLUP & CUBE :-  
 ----------------------------

  => both functions are used to calculate subtotals and grand total
 
          GROUP BY  ROLLUP(COL1,COL2,--)
          GROUP BY  CUBE(COL1,COL2,---)

 ROLLUP :- 
 --------------

 => rollup displays subtotals for each group and also display grand total

       SELECT deptno,job,SUM(sal) as totsal
       FROM emp 
       GROUP BY ROLLUP(deptno,job)
       ORDER BY deptno ASC 


                                                                29225  => grand total

               10    	CLERK     	1300
         		MANAGER 	2450
         		PRESIDENT	5000
                                                                8750   => subtotal

 	20    	ANALYST		6000
        		 CLERK		1100
       		 MANAGER	2975
                                                                11075  => subtotal
 
 CUBE :- 
 ------------

  => CUBE displays subtotals for all the group by columns and also
       displays grand total

         SELECT deptno,job,SUM(sal) as totsal
         FROM emp 
         GROUP BY CUBE(deptno,job)
         ORDER BY deptno ASC,job ASC  

         	NULL	NULL		29225.00  => grand total

	NULL	ANALYST		6000.00  => job subtotal
	NULL	CLERK		4350.00  => job subtotal
	NULL	MANAGER	8275.00
	NULL	PRESIDENT	5000.00
	NULL	SALESMAN	5600.00

	10	NULL		8750.00  => dept subtotal
	10	CLERK		1300.00
	10	MANAGER	2450.00
	20	NULL		11075.00  => dept subtotal
	20	ANALYST		6000.00
	20	CLERK		2100.00
	20	MANAGER	2975.00
	30	NULL		9400.00  => dept subtotal
	30	CLERK		950.00
	30	MANAGER	2850.00
	30	SALESMAN	5600.00

=> 

   PERSONS
   NAME   AGE   GENDER   ADDR    CITY   STATE

   display state wise and with in state gender wise population and display
   state wise and gender wise subtotals ?
 
   SELECT  state,gender,COUNT(*) as population
   FROM persons
   GROUP BY  CUBE(state,gender) 
   ORDER BY state asc,gender asc 

   NULL  NULL      ????
              MALE      ????
              FEMALE  ????
  AP                        ????
  AP        MALE       ????
  AP        FEMALE   ????

 GROUPING_ID() :- 
 --------------------------

  => function accepts group by columns and returns subtotal belongs to 
      which group by column

           ex :-  GROUPING_ID(deptno,job)

                    1    =>  subtotal belongs to 1st group by column
                    2    =>  subtotal belongs to 2nd group by column
                    3    =>  grand total

               SELECT deptno,job,SUM(sal) as totsal,
	             grouping_id(deptno,job) as subtotals
               FROM emp 
               GROUP BY CUBE(deptno,job)
               ORDER BY deptno ASC,job ASC  

 CASE statement :- 
 ------------------------

 => used to implement if-then-else  in sql
 => similar to switch case
 => using case we can return values based on condition
 => case statements are 2 types 

   1  simple case
   2  searched case 

  simple case :- 

  CASE  COLNAME
  WHEN VALUE1 THEN RETURN EXPR1
  WHEN VALUE2 THEN RETURN EXPR2
  WHEN  VALUE3 THEN RETURN EXPR3
  -----------------
  ELSE RETURN EXPR
  END

 searched case :- 
 ---------------------- 
 
  CASE  
  WHEN COND1 THEN RETURN EXPR1
  WHEN COND2 THEN RETURN EXPR2
  ---------------
  ELSE RETURN EXPR
  END

   
   SELECT deptno,job,SUM(sal) as totsal,
	                CASE grouping_id(deptno,job) 
		 WHEN 1 THEN 'Dept Subtotal'
		 WHEN 2 THEN 'Job Subtotal'
		 WHEN 3 THEN 'Grand total'
		 END as subtotals
       FROM emp 
       GROUP BY CUBE(deptno,job)
       ORDER BY deptno ASC,job ASC  
 
=> display no of employees based on salary range ?

 	 0-2000               ?
 	 2000-4000         ?
 	 ABOVE 4000     ? 

       SELECT CASE 
                     WHEN SAL BETWEEN 0 AND 2000 THEN '0-2000'
	     WHEN SAL BETWEEN 2001 AND 4000 THEN '2001-4000'
	     WHEN SAL>4000 THEN 'ABOVE 4000'
	     END AS SALRANGE , COUNT(*) AS CNT
      FROM EMP 
      GROUP BY CASE 
                         WHEN SAL BETWEEN 0 AND 2000 THEN '0-2000'
                         WHEN SAL BETWEEN 2001 AND 4000 THEN '2001-4000'
	          WHEN SAL>4000 THEN 'ABOVE 4000'
	          END 

Questions :- 
----------------

PERSONS
NAME   AGE     GENDER     ADDR    CITY    STATE 

1   display state wise population ?
2   display gender wise population ?
3   display age group wise population ?

        0-18    ?
        19-40  ?
        40-60  ?
        >60     ?

4   display state wise and with in state gender wise population
     and display state wise subtotals ?

5   display state wise and with in state age group wise population ?


 SALES
 DATEID	 	PRODID	  CUSTID    QTY     AMT    
 2020-01-01	10	   100	   1	2000

 1  display year wise total amount ?

 2  display year wise and with in year quarte wise total amount 
     and display year wise subtotals ?

 
 17-apr-23

 => increment employee salaries as follows ? 

      if deptno =10  incr sal by 10%
                       20                   15%
                       30                   20%
                      others              5%

     UPDATE EMP   
     SET SAL =  CASE DEPTNO
                        WHEN 10 THEN  SAL + (SAL*0.1)
                        WHEN 20 THEN SAL + (SAL*0.15)
                        WHEN 30 THEN SAL + (SAL*0.2)
                        ELSE SAL + (SAL*0.05)
                        END
 
 => display   SNO   TOTAL    AVG    RESULT   ?

   STUDENT 
   SNO   SNAME     S1     S2    S3
   1         A                80     90     70
   2         B               30     60     50

  SELECT  SNO,
                  S1+S2+S3  AS TOTAL,
                  (S1+S2+S3)/3 AS AVG,
                  CASE
                  WHEN S1>=35  AND S2>=35 AND S3>=35 THEN 'PASS'
                  ELSE 'FAIL'
                  END AS RESULT
  FROM STUDENT
  
=> display first day of the year ?

    SELECT  DATEADD(YY,DATEDIFF(YY,0,GETDATE()),0)  => 2023-01-01
                                          ---------------------------------------
                                                     123

    0  means => 1900-01-01

  
    DATEADD(INTERVAL , INTEGER,DATE)

   DATEADD(YY,0,0)


 => display last day of the year ?

   SELECT DATEADD(YY,DATEDIFF(YY,0,GETDATE())+1,0)-1

======================================================================

		 INTEGRITY CONSTRAINTS 
 		---------------------------------------

   => integrity constraints are rules to maintain data quality.
   => used to prevent users from entering invalid data.
   => used to enforce rules like min bal must be 1000
  
   NOT NULL
   UNIQUE
   PRIMARY KEY
   CHECK
   FOREIGN KEY
   DEFAULT

 => above constraints can be declared in two ways 

   1  column level
   2  table level 

 COLUMN LEVEL :- 
 --------------------------

 => if constraints are declared immediately after declaring column then it is called column level

     CREATE TABLE TABNAME
     (
           COLNAME     DATATYPE(SIZE)  CONSTRAINT ,
           COLNAME     DATATYPE(SIZE)  CONSTRAINT ,
            ---------------------
      )

  
 NOT NULL :- 
 -----------------

 => NOT NULL  constraint doesn't accept null values.

     CREATE TABLE emp77
     (
        empno INT ,
        ename  VARCHAR(10) NOT NULL
      )

      INSERT INTO EMP77 VALUES(100,NULL) => ERROR

  UNIQUE :-  
  --------------
 
  => unique constraint doesn't  accept duplicates 

 ex :- 

    CREATE TABLE CUST
    (
      CID   		INT  ,
      NAME  	VARCHAR(10) NOT NULL,
      EMAILID	VARCHAR(10) UNIQUE
     )

 
     INSERT INTO CUST VALUES(100,'A','abc@gmail.com')
     INSERT INTO CUST VALUES(101,'B','abc@gmail.com')   => ERROR
     INSERT INTO CUST VALUES(102,'C',NULL)
     INSERT INTO CUST VALUES(103,'D',NULL)                    => ERROR

  NOTE :- unique constraint doesn't accept duplicates but allows one null 

18-APR-23

 PRIMARY KEY :- 
 ----------------------

 =>  PRIMARY KEY doesn't accept duplicates & nulls. 
 =>  primary key is the combination of unique & not null.
 => in table one column must be there to uniquely identify the records and that
      column must be declared  with primary key,

 ex :- 

  CREATE TABLE emp11
  (
      empid   INT   PRIMARY KEY,
      ename  VARCHAR(10) NOT NULL,
      sal        MONEY
   )

  INSERT INTO emp11 VALUES(100,'A',5000)
  INSERT INTO emp11 VALUES(100,'B',6000)         => ERROR
  INSERT INTO emp11 VALUES(NULL,'C',4000)      => ERROR
     
  => because it is not allowing duplicates & nulls  into empid , so using empid column
       we can uniquely identify the records.
 
  =>  only one primary key is allowed per table , if we want multiple primary keys then\
        declare one column with primary key and  other columns with unique  not null.
     

       CREATE TABLE CUST
       (
        CUSTID   INT   PRIMARY KEY,
        NAME     VARCHAR(10) NOT NULL,
        AADHARNO  NUMERIC(12)  UNIQUE NOT NULL,
        PANNO      CHAR(10)   UNIQUE NOT NULL
       )
   
 => difference between unique & primary key  ?

                 UNIQUE                                          PRIMARY KEY

   1         allows one null                                   doesn't allow nulls 

   2         multiple columns can                         one column can be
              be declared with unique                     declared with primary key

 CANDIDATE KEY :- 
  -------------------------

  =>  a field eligible for primary key is called candidate key.

        EX :-

            VEHICLES
            VEHNO     NAME     MODEL     COST     CHASSISNO 
 
            candidate keys	 :-  	VEHNO,CHASSISNO
            
            primary key                   :-            VEHNO

           secondary key               :-             CHASSISNO
           or
           alternate key
            	 

  => secondary key or alternate keys are declared by using  UNIQUE   NOT NULL.

  CHECK :- 
  -------------

  =>  use check constraint when rule based on condition.

             syn :-   CHECK(condition)

  example 1 :-    sal must be min 3000

       CREATE TABLE emp12
       (
             empid  INT  PRIMARY KEY,
             ename  VARCHAR(10) NOT NULL,
             sal       MONEY  CHECK(sal>=3000)
       )

	INSERT INTO EMP12 VALUES(100,'A',1000)   => ERROR
	INSERT INTO EMP12 VALUES(101,'B',5000)
	INSERT INTO EMP12 VALUES(102,'C',NULL)

    2    gender must be 'm','f' ? 

          gender    char(1)     CHECK(gender IN ('m','f'))

   3     amt must be multiple of 100  ?
 
          amt   money    CHECK(amt%100=0)

  4     pwd must be min 8 chars 

         pwd    varchar(12)    CHECK( LEN(pwd) >= 8)


   5    emailid  must contain '@'
                      must end with '.com' or '.co' or '.in'

        emailid   varchar(20)  check(emailid like '%@%'
                                                     and
                                                     (
                                                          emailid like '%.com'
                                                          or
                                                         emailid like '%.co'
                                                         or
                                                        emailid like '%.in'
                                                     ))


FOREIGN KEY :- 
-----------------------

 => foreign key is used to establish relationship between two tables 

 
 PROJECTS
 projid    name    duration    cost     client
 100      A           5 YEARS   300     TATA MOTORS
 101      B          3 YEARS   200      DBS BANK
 102      C          4 YEARS   400      L&T

 EMP
 empid   ename   sal            projid    REFERENCE projects(projid)
 1           K           5000        100
 2           S           4000        101
 3           D           3000        100
 4           E           4000        NULL
 
 => to establish relationship between two tables then take primary key of one table  
      and add it to another table as foreign key  and declare with references constraint.

 => values entered in foreign key column should match with values entered in 
      primary key column

 => foreign key allows duplicates & nulls 

 => after declaring foreign key a relationship is established between two tables 
      called parent/child relationship.

 =>  primary key table is parent and foreign key table is child.

   CREATE TABLE projects
   (
       projid  INT   PRIMARY KEY,
       pname  VARCHAR(10),
       client    VARCHAR(10)
   ) 

  INSERT INTO projects VALUES(100,'A','TATA')
  INSERT INTO projects VALUES(101,'B','DBS')

  CREATE TABLE emp_proj
  (
     empid   INT PRIMARY KEY,
     ename  VARCHAR(10) NOT NULL,
     sal        MONEY  CHECK(sal>=3000),
     projid    INT  REFERENCES projects(projid)
   )

  INSERT INTO emp_proj VALUES(1,'A',5000,100)
  INSERT INTO emp_proj VALUES(2,'B',6000,999)  => ERROR
  INSERT INTO emp_proj VALUES(3,'C',4000,NULL)
  INSERT INTO emp_proj VALUES(4,'D',3000,100)

 Assignment :- 

 ACCOUNTS
 ACCNO     ACTYPE     BAL

 Rules :-  
 ----------
 
 1   accno should not be duplicate & null
 2   actype must be 's' or 'c'
 3   bal must be min 1000

 TRANSACTIONS
 TRID    TTYPE    TDATE     TAMT     ACCNO
 
 Rules :- 
 ----------
 
 1  trid should not be duplicate & null
 2  ttype must be 'w' or 'd'
 3  tamt must be multiple of 100
 4  accno should match with accounts table accno


 LOANS
 LOANID      TYPE     AMT    ACCNO

 Rules :- 

  1   loanid should not be duplicate & null
  2   type must 'p' , 'h', 'g' 
  3   accno  should match with accounts table accno

  19-apr-23

   DEFAULT :- 
   ---------------

   => a  column can be declared with default value  as follows

     ex :-     hiredate   date   default  getdate()

  => while inserting if we skip hiredate then sql server inserts default value.

  ex :-  

    CREATE TABLE emp22
    (
        empno  INT ,
        ename  VARCHAR(10),
        hiredate DATE  DEFAULT GETDATE())
    )

   INSERT INTO emp22(empno,ename)  VALUES(100,'A') 
   INSERT INTO emp22  VALUES(101,'B','2023-01-01') 
   INSERT INTO emp22  VALUES(102,'C',NULL) 

   SELECT * FROM emp22

   empno	ename	hiredate
   100	A	2023-04-19
   101	B	2023-01-01
   102	C	NULL

 TABLE LEVEL :- 
 ----------------------

 =>  if constraints is declared after declaring all columns then it is called table level.
 =>  use table level to declare constraint multiple columns or combination of columns.

      CREATE TABLE <tabname>
      (
         colname  datatype(size)  ,
         colname  datatype(size),
          ------------------------,
                    CONSTRAINT(col1,col2,---)
       )

   Declaring check constraint at table level :-
   -------------------------------------------------------

   PRODUCTS
   prodid    pname     price     mfd_dt    	 exp_dt  
   1           A              100      2023-04-01  2023-01-01      invalid
   
            rule :-  exp_dt > mfd_dt 

   => above example rule based on multiple columns so cannot be declared at column level
        and must be declared at table level.

       CREATE TABLE products
       (
         prodid  INT  PRIMARY KEY,
         pname  VARCHAR(10) NOT NULL,
         price     MONEY,
         mfd_dt   DATE,
         exp_dt    DATE,
                 CHECK(exp_dt > mfd_dt)
        )

   INSERT INTO products VALUES(100,'A',1000,GETDATE(),'2023-01-01') => ERROR
   INSERT INTO products VALUES(100,'A',1000,'2023-01-01',GETDATE()) => 1 row created

  Composite primary key :- 
  ---------------------------------

  => if primary key is declared for combination of columns then it is called composite primary key

  => sometimes in tables we may not uniquely identify the records by using single column
       and we need combination of columns to uniquely identify , so that combination
       shoule be declared primary key at table level.

 => in composite primary key combination should not be duplicate

     example  1  :-

     STUDENT		 COURSE
     SID	SNAME		 CID	NAME
     1	A		 10	.NET
     2	B		 11	 SQL SERVER

    REGISTRATIONS
    SID	CID	DOR	FEE
    1	10	?	?
    1	11	?	?
    2	10	?	?

  => in the above example sid,cid combination uniquely identifies the records , so 
       declare this combination as primary key at table level.

  CREATE TABLE student
  (
     sid  INT  PRIMARY KEY,
     sname VARCHAR(10) NOT NULL
  )

  INSERT INTO student VALUES(1,'A'),(2,'B')

  CREATE TABLE course
  (
    cid  INT  PRIMARY KEY,
    cname VARCHAR(10) NOT NULL
   )

  INSERT INTO course VALUES(10,'.NET'),(11,'SQL SERVER')

  CREATE TABLE registrations
  (
      sid  INT  REFERENCES student(sid),
      cid  INT  REFERENCES course(cid),
      dor DATE,
      fee MONEY ,
               PRIMARY KEY(sid,cid)
   )

 
   INSERT INTO registrations VALUES(1,10,GETDATE(),2000)
   INSERT INTO registrations VALUES(1,11,GETDATE(),2000)
   INSERT INTO registrations VALUES(2,10,GETDATE(),2000)
   INSERT INTO registrations VALUES(1,10,GETDATE(),2000)  => ERROR

  Example 2 :- 

  SALES
  DATEID	 	PRODID	   CUSTID    QTY     AMT 
  2023-04-18	100	   10	     1	2000
  2023-04-18            101               10                1        1000
  2023-04-18            100	  11	     1         2000
  2023-04-19            100              10                 1        2000

  => identify primary key and write create table script ?

composite foreign key :- 
------------------------------

=> if foreign key declared for combination then it is called composite foreign key.
=> a composite foreign key refers composite primary key.

  
Example :-

    REGISTRATIONS
    SID	CID	DOR	FEE
    1	10	?	?
    1	11	?	?
    2	10	?	?

    CERTIFICATES
    CERTNO     DOI  	SID	CID
    1000            ???	1	10
    1001	        ???   1               11
    1002            ???    2               11   => INVALID


 => in the above example SID,CID combination should match with registrations table
      SID,CID combination ,so declare this combination as foreign key at table level

   CREATE TABLE CERTIFICATES
   (
      CERTNO   INT   PRIMARY KEY,
      DOI           DATE,
      SID           INT,
      CID          INT,
               FOREIGN KEY(SID,CID)   
                              REFERENCES REGISTRATIONS(SID,CID)
      )

 
1  which of the following constraint cannot be declared at table level ?

  A    UNIQUE
  B   CHECK
  C   NOT NULL
  D   PRIMARY KEY
  E   FOREIGN KEY 

   ANS :- C
  

2   Which statements are true regarding constraints ?

A  a foreign key cannot contain NULL value      F
B  a column with UNIQUE constraint can contain NULL value   T
C  a constraint is enforced only for the INSERT operation on a table  F
D  all constraints can be defined at column level and table level.    F

3 

 Which CREATE TABLE statement is valid?

A. CREATE TABLE ord_details
(ord_no NUMERIC(2) PRIMARY KEY,
item_no NUMERIC(3) PRIMARY KEY,
ord_date DATE NOT NULL);

B. CREATE TABLE ord_details
(ord_no NUMERIC(2) UNIQUE, NOT NULL,
item_no NUMERIC(3),
ord_date DATE DEFAULT GETDATE() NOT NULL);

C. CREATE TABLE ord_details
(ord_no NUMERIC(2) ,
item_no NUMERIC(3),
ord_date DATE DEFAULT NOT NULL,
   UNIQUE (ord_no),
  PRIMARY KEY (ord_no));

D. CREATE TABLE ord_details
(ord_no NUMERIC(2),
item_no NUMERIC(3),
ord_date DATE DEFAULT GETDATE() NOT NULL,
           PRIMARY KEY (ord_no, item_no));


20-APR-23
 
Adding constraints to existing table :- 
------------------------------------------------

 => "ALTER" command is used to add constraints to existing table.

       CREATE TABLE emp99
       (
          empno  INT ,
          ename  VARCHAR(10) ,
          sal        MONEY,
          dno       INT 
       )

 Adding primary key :- 
 ---------------------------

 => primary key cannot be added to nullable column.
 => to add primary key first change the column to not null. 

 Ex :- 

  => add primary key to empno  ?

    STEP 1 :-  change column empno to not null

     ALTER TABLE emp99
             ALTER COLUMN empno  VARCHAR(10) NOT NULL
 
    STEP 2 :-  add primary key to empno 

    ALTER TABLE emp99
            ADD PRIMARY KEY(empno) 
  
  Adding check :- 
 ----------------------

  => add check constraint with condition sal >= 3000 ?
 
       ALTER TABLE emp99 
                  ADD CHECK(sal>=3000) 

        
          ALTER TABLE emp 
                  ADD CHECK(sal>=3000)  => ERROR

   note :- above command returns error because some of the employee salaries are
   less than 3000 , while adding constraint sql server also validates existing data ,
   if existing data satisfies the condition then constraint is added otherwise 
   not added.

   WITH NOCHECK :- 
   --------------------------

   =>  if constraint is added with "NO CHECK"  then sql server will not validate existing
         data and it validates only new data

       ALTER TABLE emp  
                WITH NOCHECK ADD CHECK(sal>=3000)  

   Adding foreign key :- 
  ---------------------------

   => add foreign key to dno that refers dept table primary key i.e. deptno 
 
     ALTER TABLE emp99
           ADD FOREIGN KEY(dno)  REFERENCES dept(deptno) 
 
  changing from NULL to NOT NULL :- 
  -------------------------------------------------

  =>  modify the column ename to not null ?

      ALTER TABLE emp99
             ALTER COLUMN ename VARCHAR(10) NOT NULL 

   Droping constraints :- 
   -----------------------------
 
   ALTER TABLE <TABNAME>
              DROP  CONSTRAINT  <NAME> 

 => drop check constraint in emp99 table ?

     ALTER TABLE emp99
         DROP CONSTRAINT  CK__emp99__sal__72C60C4A

 => drop primary key in dept table ?

       ALTER TABLE DEPT
               DROP CONSTRAINT PK__DEPT__E0EB08D79BEB42A8 => ERROR

      DROP TABLE DEPT  => ERROR 

      TRUNCATE TABLE DEPT  => ERROR


  NOTE :- 

   1   primary key cannot be dropped if referenced by some fk
   2   primary key table cannot be dropped if referenced by some fk
   3   primary key table cannot be truncated if referenced by some fk

21-apr-23

DELETE rules :- 
----------------------

 1  ON DELETE NO ACTION  (DEFAULT)
 2  ON DELETE CASCADE
 3  ON DELETE SET NULL
 4  ON DELETE SET DEFAULT

 => these rules are declared with foreign key.
 => delete rule specifies how child rows are affected if parent row is deleted.
 
 ON DELETE NO ACTION :- 
  ----------------------------------

 => parent row cannot be deleted if associated with child rows.

  CREATE TABLE dept88
  (
   dno int primary key,
   dname varchar(10) 
  )

  INSERT INTO dept88 VALUES(10,'HR'),(20,'IT') 

  CREATE TABLE emp88
  (
   empno INT PRIMARY KEY,
   ename VARCHAR(10),
   dno    INT  REFERENCES dept88(dno)
 )

  INSERT INTO emp88 VALUES(1,'A',10),(2,'B',10)

  DELETE FROM dept88 WHERE dno = 10  => ERROR

  scenario :- 
  --------------

  ACCOUNTS
  ACCNO     BAL
  100
  101

  LOANS
  ID	TYPE	AMT	ACCNO   REFERENCES  ACCOUNTS(ACCNO)
 1	H	30	100
 2	C	10	100

 RULE :-  account closing is not possible if associated with loans

 ON DELETE CASCADE :- 
 ----------------------------------

 =>  if parent row is deleted then it is deleted along with child rows

   CREATE TABLE dept88
  (
   dno int primary key,
   dname varchar(10) 
  )

  INSERT INTO dept88 VALUES(10,'HR'),(20,'IT') 

  CREATE TABLE emp88
  (
   empno INT PRIMARY KEY,
   ename VARCHAR(10),
   dno    INT  REFERENCES dept88(dno)
                    ON DELETE CASCADE
 )

  INSERT INTO emp88 VALUES(1,'A',10),(2,'B',10)

  DELETE FROM dept88 WHERE dno=10   =>   1  row deleted

  SELECT * FROM emp88     => no rows 

 scenario :- 
 ------------

 ACCOUNTS
 ACCNO    BAL
100	 10000
1O1	 20000

TRANSACTIONS
TRID    TTYPE     TDATE      TAMT     ACCNO    REFERENCES ACCOUNTS(ACCNO)
1          W             ??             1000     100           ON DELETE CASCADE
2          D              ??             2000     100

Rule :-  if account is closed then along with account delete transactions also 


ON DELETE SET NULL :- 
---------------------------------

 => if  parent row is deleted then it is deleted but child rows are not deleted  but fk will be
      set to null.

    CREATE TABLE dept88
  (
   dno int primary key,
   dname varchar(10) 
  )

  INSERT INTO dept88 VALUES(10,'HR'),(20,'IT') 

  CREATE TABLE emp88
  (
   empno INT PRIMARY KEY,
   ename VARCHAR(10),
   dno    INT  REFERENCES dept88(dno)
                    ON DELETE SET NULL
 )

  INSERT INTO emp88 VALUES(1,'A',10),(2,'B',10)

    DELETE FROM DEPT88 WHERE DNO=10   => 1 ROW DELETED

  SELECT * FROM EMP88
 
  EMPNO	ENAME	DNO 
  1	A	NULL
  2	B	NULL

 scenario :- 
 -------------

 PROJECTS
 projid   pname   duration
 100
101

EMP
empid	ename	projid   REFERENCES projects(projid) 
1	A	100     ON DELETE SET NULL
2	B	100

 RULE :-  if project is deleted (completed)  then set the employee projid to null

ON DELETE SET DEFAULT :- 
 --------------------------------------

=>  if  parent row is deleted then it is deleted but child rows are not deleted  but fk will be
      set to default value.

   CREATE TABLE dept88
  (
   dno int primary key,
   dname varchar(10) 
  )

  INSERT INTO dept88 VALUES(10,'HR'),(20,'IT') 

  CREATE TABLE emp88
  (
   empno INT PRIMARY KEY,
   ename VARCHAR(10),
   dno    INT  DEFAULT 20 
                    REFERENCES dept88(dno)
                    ON DELETE SET DEFAULT
 )

  INSERT INTO emp88 VALUES(1,'A',10),(2,'B',10)

  DELETE FROM DEPT88 WHERE DNO = 10  => 1 row affected

 SELECT * FROM EMP88

  ENO	ENAME	DNO
  1	A	20
 2	B	20

Summary :- 

 importance of constraints
 types of constraints
 declaring constraints
     column level
     table level
 adding constraints to existing table 
 droping constraints
 delete rules


======================================================================

				JOINS
				---------

    
 =>  join is an operation performed to display data from two or more tables.

 => in DBs related data stored in multiple tables , to gather or to combine data
      stored in multiple tables  we need to join those tables.

 Example :- 

    orders                                                  customers
    ordid      orddt    deldt       cid                cid      name         addr
    1000      ??         ??         10                 10        A              HYD
    1001                                11                 11        B              HYD
     1002                               12                 12        C             HYD

   output :- 
 
    ordid    orddt    deldt     name    addr 
    1000    ??        ??        A           HYD

 Types of Joins :- 
 --------------------

 1  INNER JOIN / EQUI JOIN
 2  OUTER JOIN
        LEFT OUTER
        RIGHT OUTER
        FULL OUTER
 3  NON EQUI JOIN
 4  SELF JOIN
 5  CROSS / CARTESIAN JOIN

 INNER JOIN / EQUI JOIN :-  
 ------------------------------------

  =>  to perform inner join between the two tables there must be a common field and 
        name of the common field need not to be same and pk-fk relationship is not compulsory

  => inner join is performed based on the common field with same datatype.

       SELECT columns
       FROM  tab1  INNER JOIN tab2 
           ON   join condition 

 join condition :- 
 --------------------

=>  based on the given join condition sql server joins the records of two tables.
=>  join condition determines which record of 1st table joined with which record of 2nd table.

             table1.commonfield =  table2.commonfield

  
 Example :- 

 EMP					DEPT
 EMPNO	ENAME	SAL	DEPTNO		DEPTNO	DNAME		LOC
  1	A	5000	10		10	ACCOUNTS	NY	
  2	B	3000	20		20	RESEARCH		
  3	C	4000	30		30	SALES	
  4	D	3000	10		40	OPERATIONS	
  5	E	2000	NULL

  =>  display     ENAME      SAL       DNAME     LOC    ?
                        --------------------       ----------------------
                               EMP                    DEPT

        SELECT  ENAME,SAL,DNAME,LOC
            FROM EMP INNER JOIN DEPT
                ON  EMP.DEPTNO = DEPT.DEPTNO 

 => display    ENAME  SAL   DEPTNO   DNAME   LOC   ?

       SELECT  ENAME,SAL,
                      DEPTNO ,DNAME,LOC
            FROM EMP INNER JOIN DEPT
                ON  EMP.DEPTNO = DEPT.DEPTNO   => ERROR (ambiguity)

     NOTE :-  
 
      in join queries  declare table alias and prefix column names with table alias for two reasons

     1  to avoid ambiguity error
     2  for faster execution

    SELECT   E.ENAME,E.SAL,
                    D.DEPTNO ,D.DNAME,D.LOC
        FROM EMP AS E INNER JOIN DEPT AS D
             ON  E.DEPTNO = D.DEPTNO
      
    => display employees working at NEW YORK loc ?

         SELECT E.ENAME,D.DNAME,D.LOC
            FROM EMP AS E INNER JOIN DEPT AS  D 
                ON  E.DEPTNO = D.DEPTNO    /* join condition */
            WHERE D.LOC = 'NEW YORK'     /*  filter condition */

  joining more than 2 tables :- 
  --------------------------------------

  => if no of tables increases no of join conditions also increases. 
  => to join N tables N-1 join conditions required.

    SELECT  columns
       FROM  tab1 INNER JOIN tab2
            ON   join condition
                           INNER JOIN tab3
             ON  join condition
                           -------------------

 ex :- 
 
  EMP             DEPT               LOCATIONS            COUNTRIES
  empno          deptno              locid                         country_id
  ename          dname              city                           country_name
  sal                locid                  state                         
  deptno                                   country_id 
  
 => display    ENAME    DNAME     CITY    STATE    COUNTRY_NAME  ?
                     ----------    -----------     ------------------    --------------------------
                     EMP        DEPT         LOCATIONS        COUNTRIES

     SELECT   e.ename,
                     d.dname,      
                     l.city,l.state,
                     c.country_name as country
     FROM emp as e INNER JOIN dept as d
           ON e.deptno = d.deptno 
                                INNER JOIN locations as l
           ON d.locid  =  l.locid
                                INNER JOIN countries as c
           ON l.country_id = c.country_id 

 OUTER JOIN :- 
 ---------------------

=>  inner join returns only matching records but won't return unmatched records , 
      to display unmatched records perform outer join.

example :-

 EMP					DEPT
 EMPNO	ENAME	SAL	DEPTNO		DEPTNO	DNAME		LOC
  1	A	5000	10		10	ACCOUNTS	NY	
  2	B	3000	20		20	RESEARCH		
  3	C	4000	30		30	SALES	
  4	D	3000	10		40	OPERATIONS => unmatched row
  5	E	2000	NULL =>  unmatched row

 
 => outer join is 3 types 

   1  LEFT JOIN
   2  RIGHT JOIN
   3  FULL JOIN

   LEFT JOIN :- 
   ------------------

  =>  returns all rows from left side table and matching rows from right side table.

       SELECT  E.ENAME,D.DNAME
          FROM  EMP AS E  LEFT JOIN DEPT AS D
               ON  E.DEPTNO = D.DEPTNO

     => returns all rows from emp table and matching rows from dept table

       A	ACCOUNTS
       B	RESEARCH
       C	SALES
       D	ACCOUNTS
       E	NULL                => unmatched row from emp 

 RIGHT JOIN :- 
 ---------------------

  => returns all rows from right side table and matching rows from left side table

       SELECT  E.ENAME,D.DNAME
          FROM  EMP AS E  RIGHT JOIN DEPT AS D
               ON  E.DEPTNO = D.DEPTNO

  => returns all rows from dept table and matching rows from emp table

 	A	ACCOUNTS
	B	RESEARCH
	C	SALES
	D	ACCOUNTS
	NULL	OPERATIONS => unmatched from dept 

25-APR-23

 FULL JOIN :- 
 ------------------

  => full join returns all rows from both tables 

       SELECT  E.ENAME,D.DNAME
          FROM  EMP AS E  FULL JOIN DEPT AS D
               ON  E.DEPTNO = D.DEPTNO

	A	ACCOUNTS
	B	RESEARCH
	C	SALES
	D	ACCOUNTS
 	E	NULL        => unmatched from emp	
                NULL	OPERATIONS => unmatched from dept

 Displaying unmatched records :-
 ---------------------------------------------

 left table :- 
 ---------------

       SELECT  E.ENAME,D.DNAME
          FROM  EMP AS E  LEFT JOIN DEPT AS D
               ON  E.DEPTNO = D.DEPTNO
        WHERE D.DNAME IS NULL 

            E      NULL

 right table :- 
 ----------------
 
       SELECT  E.ENAME,D.DNAME
          FROM  EMP AS E RIGHT JOIN DEPT AS D
              ON  E.DEPTNO = D.DEPTNO
        WHERE  E.ENAME IS NULL

      NULL	   OPERATIONS 

 both tables :- 
 ------------------

       SELECT  E.ENAME,D.DNAME
          FROM  EMP AS E FULL JOIN DEPT AS D
               ON  E.DEPTNO = D.DEPTNO
        WHERE E.ENAME IS NULL 
	      OR
	      D.DNAME IS NULL

       E        	NULL
      NULL   	OPERATIONS

scenario :- 
---------------

  PROJECTS
  projid     pname   duration 
 100        A             5 YEARS
 101        B            3 YEARS
 102        C            2  YEARS 
 
  EMP
  EMPNO	 ENAME	PROJID
  1	 K	100
  2	 M	101
  3	 C	NULL

 => display employee details with project details ?

 => display employee details with project details and also display
      employees not assigned to any project ?

 => display employee details with project details and also display
      projects where no employee assigned to it ?

Non Equi Join :- 
---------------------

 =>  Non equi join is performed between the tables not sharing a common field
 
     SELECT columns
     FROM tab1  JOIN  tab2 
         ON  join condition

 => here join condition is not based on "=" operator  and may be based on 
      >   <    between operators.

     Example :-

      EMP				SALGRADE
      EMPNO    ENAME   SAL		GRADE	LOSAL	HISAL
      1	       A             3000		1	700	1000
      2               B             1000		2	1001	2000
      3               C             4000		3	2001	3000
      4               D             2000		4	3001	4000
      5               E             1500		5	4001	9999

    display  ENAME	SAL	GRADE  ?
                 -------------------         ------------
                         EMP                 SALGRADE

      SELECT  E.ENAME,E.SAL,S.GRADE
         FROM  EMP AS E  JOIN SALGRADE AS S
             ON   E.SAL BETWEEN S.LOSAL AND S.HISAL 

 	A	3000	3
	B	1000	1
	C	4000	4
	D	2000	2
	E	1500	2

 => display grade 4 employee list ?

      SELECT  E.ENAME,E.SAL,S.GRADE
         FROM  EMP AS E  JOIN SALGRADE AS S
             ON   E.SAL BETWEEN S.LOSAL AND S.HISAL 
       WHERE  S.GRADE = 4 

 => display  ENAME    DNAME     GRADE    ?
                   ----------    -----------     ----------
                     EMP        DEPT        SALGRADE

   SELECT E.ENAME,D.DNAME,S.GRADE
       FROM EMP AS E  INNER JOIN DEPT AS D
           ON  E.DEPTNO = D.DEPTNO
                                     JOIN SALGRADE S
            ON E.SAL  BETWEEN S.LOSAL AND S.HISAL 

 SELF JOIN :- 
 ------------------

  => joining a table to itself is called self join.
  => in self join a record in one table joined with another record of same table.
  => to perform self join the same table must be declared two times with
       different alias.

           FROM  EMP AS  X   JOIN   EMP AS  Y

 Example :- 

   EMP X				  	EMP Y	
   EMPNO       ENAME	MGR		EMPNO	ENAME	MGR
   1	     A		NULL		1	A	NULL
   2	     BLAKE	1		2	BLAKE	1
   3	     C		1		3	C	1
   4	     D		2		4	D	2
   5	     E		3		5	E	3
  
26-apr-23

 => display  ENAME	    MGRNAME   ?

      SELECT  X.ENAME , Y.ENAME AS MANAGER
      FROM EMP AS X   JOIN  EMP AS Y
           ON  X.MGR = Y.EMPNO

             B            A
             C           A
             D           B
             E           C

 => display employees reporting to blake ?

       SELECT  X.ENAME , Y.ENAME AS MANAGER
          FROM  EMP AS X   JOIN  EMP AS Y
               ON  X.MGR = Y.EMPNO
        WHERE Y.ENAME='BLAKE' 

  => display blake's manager name ?

       SELECT  X.ENAME , Y.ENAME AS MANAGER
          FROM  EMP AS X   JOIN  EMP AS Y
               ON  X.MGR = Y.EMPNO
       WHERE  X.ENAME='BLAKE' 

 => employees earning more than their manager ?

     SELECT  X.ENAME ,X.SAL,
                    Y.ENAME AS MANAGER,Y.SAL AS MGRSAL
         FROM  EMP AS X   JOIN  EMP AS Y
              ON  X.MGR = Y.EMPNO
      WHERE  X.SAL > Y.SAL

 => employees joined before their manager ?

      SELECT  X.ENAME ,X.HIREDATE, 
                      Y.ENAME AS MANAGER ,Y.HIREDATE AS MGRHIRE
         FROM  EMP AS X   JOIN  EMP AS Y
             ON  X.MGR = Y.EMPNO
      WHERE X.HIREDATE  < Y.HIREDATE  

 Question :-
  -------------

    TEAMS
    ID	COUNTRY
    1	IND
    2	AUS
    3	ENG

   write a query to display following output ?
 
   IND  VS   AUS
   IND  VS   ENG
   AUS  VS  ENG

     TEAMS A                                 TEAMS B
    ID	COUNTRY                    ID	COUNTRY
    1	IND		     1	IND
    2	AUS		     2	AUS
    3	ENG		     3	ENG

  
CROSS JOIN / CARTESIAN JOIN :- 
-----------------------------------------------

 =>  cross join returns cross product or cartesian product of two tables.
 
    A = 1,2
    B = 3,4
   AXB = (1,3) (1,4) (2,3) (2,4)
  
  => if cross join performed between two tables then all the records of 
       1st table joined with all the records of 2nd table.

   => to perform cross join submit the join query without join condition.

     SELECT  E.ENAME,D.DNAME
         FROM  EMP AS E  CROSS JOIN DEPT AS D

GROUP BY & JOIN :-
-----------------------------

  =>  display dept wise total sal ?  display dept names ?

       SELECT D.DNAME,SUM(E.SAL) AS TOTSAL
          FROM EMP AS E  INNER JOIN DEPT AS D
               ON  E.DEPTNO = D.DEPTNO 
    GROUP BY D.DNAME

 FROM EMP AS E INNER JOIN DEPT AS D :-
--------------------------------------------------------------

   EMP					DEPT
 EMPNO	ENAME	SAL	DEPTNO		DEPTNO	DNAME		LOC
  1	A	5000	10		10	ACCOUNTS	NY	
  2	B	3000	20		20	RESEARCH		
  3	C	4000	30		30	SALES	
  4	D	3000	10		40	OPERATIONS  
  5	E	2000	20

ON E.DEPTNO = D.DEPTNO :-
------------------------------------------

  1	A	5000	ACCOUNTS
  2	B	3000	RESEARCH
  3	C	4000	SALES
  4	D	3000	ACCOUNTS
  5	E	2000	RESEARCH

GROUP BY D.DNAME :- 
--------------------------------

   ACCOUNTS
		1	A	5000
		4	D	3000

  RESEARCH
		2	B	3000
		5	E	2000

   SALES	
		3	C	4000

   SELECT D.DNAME,SUM(E.SAL) AS TOTSAL :- 
   ----------------------------------------------------------------
 
   ACCOUNTS	8000
   RESEARCH	5000
   SALES		4000

 Assignment :- 
 --------------------

 SALES
 DATEID	 	PRODID	  CUSTID	  QTY	AMT
 2020-01-01	100	  10	   1	2000
 
 PRODUCTS
 PRODID	 PNAME	 PRICE	CATEGORY
 100	 AAA         2000        ELECTRONICS

 CUSTOMER
 CUSTID	 NAME	ADDR	COUNTRY
 10	 KKK	HYD	IND

  => display year wise total amount ?
  => display category wise total amount ?
  => display country wise total amount ? 
  => display year wise,country wise,category wise total amount ?

================================================================

 SET OPERATORS :- 
 ---------------------------

 UNION
 UNION ALL
 INTERSECT
 EXCEPT

 A                =   1,2,3,4
 B                =   1,2,5,6

  A UNION B 	=   1,2,3,4,5,6
 A  UNION ALL B      =   1,2,3,4,1,2,5,6
 A  INTERSECT B     =   1,2
 A  EXCEPT B           =   3,4
 B  EXCEPT A          =    5,6

 => in SQL SERVER  set operations are performed between records return by two queries

   SELECT  STATEMENT 1
   UNION / UNION ALL / INTERSECT / EXCEPT 
   SELECT STATEMENT 2
 
  Rules :- 
 
  1  no of columns return by both queries must be same.
  2  corresponding columns datatype must be same.

 SELECT job FROM emp WHERE deptno = 20

CLERK
MANAGER
ANALYST
CLERK
ANALYST

 SELECT job FROM emp WHERE deptno = 30

SALESMAN
SALESMAN
SALESMAN
MANAGER
SALESMAN
CLERK

 UNION :- 
 ------------

 =>  combines rows return by two queries
 =>  duplicates are eliminated
 =>  result is sorted 

    SELECT job FROM emp WHERE deptno = 20 
    UNION
    SELECT job FROM emp WHERE deptno = 30

 ANALYST 
CLERK
MANAGER
SALESMAN

27-apr-23

 => difference between  UNION & JOIN ?

                    UNION                                        JOIN 

   1    combines rows                                      combines columns 

   2    horizontal merge                                    vertical merge

   3    performed between                                performed between
         two similar structures                             two dissimilar structures

  T1       T2
  F1       C1
  1         10
  2         20
  3         30

 T1 UNION T2 :-                    T1 JOIN T2  :- 
 ---------------------                   ----------------

 1			1	10
 2			2	20
 3			3	30
 10
 20
 30

scenario :-
--------------

EMP_US
ENO  ENAME  SAL   DNO
                                                                       DEPT
EMP_IND                                                        DNO  DNAME   LOC
ENO  ENAME  SAL    DNO

 =>  total employee list ?

      SELECT * FROM EMP_US
      UNION
      SELECT * FROM EMP_IND 

 => employees working at us loc with dept details ?
 
        SELECT E.*,D.*
           FROM EMP_US AS E INNER JOIN DEPT AS D
              ON E.DNO = D.DNO 
 
 => total employees with dept details ?
 
        SELECT E.*,D.*
           FROM EMP_US AS E INNER JOIN DEPT AS D
              ON E.DNO = D.DNO 
        UNION
        SELECT E.*,D.*
           FROM EMP_IND AS E INNER JOIN DEPT AS D
              ON E.DNO = D.DNO 

UNION ALL :- 
------------------

 => union all combines rows return by two queries
 => duplicates are not eliminated
 => result is not sorted 

    SELECT job FROM emp WHERE deptno = 20 
    UNION ALL
    SELECT job FROM emp WHERE deptno = 30

	CLERK
	MANAGER
	ANALYST
	CLERK
	ANALYST
	SALESMAN
	SALESMAN
	SALESMAN
	MANAGER
	SALESMAN
	CLERK

 => difference between union & union all ?

            UNION                                UNION ALL
 
  1      duplicates are eliminated      duplicates are not eliminated

  2      result is sorted                     result is not sorted
 
  3      slower                                  faster

 INTERSECT :- 
 ------------------

  => returns common values 

    SELECT job FROM emp WHERE deptno = 20 
    INTERSECT
    SELECT job FROM emp WHERE deptno = 30
   
    CLERK
    MANAGER

 EXCEPT :- 
 ---------------

 => returns values present in 1st query output and not present in 2nd query
      output

     SELECT job FROM emp WHERE deptno = 20 
     EXCEPT
     SELECT job FROM emp WHERE deptno = 30

     ANALYST

     SELECT job FROM emp WHERE deptno = 30 
     EXCEPT
     SELECT job FROM emp WHERE deptno = 20
   
     SALESMAN 

  Question :- 
  ---------------
 
 T1	T2
 F1	C1
 1	1
 2	2
 3	3
 10	40
 20	50
 30	60

 write the output  for the following operations ?

 1  INNER JOIN
 2  LEFT JOIN
 3  RIGHT JOIN
 4  FULL JOIN
 5  UNION
 6  UNION ALL
 7 INTERSECT
 8  EXCEPT

=============================================================

 SUB-QUERIES / NESTED QUERIES :-
 --------------------------------------------------
 
 => a query in another query is called subquery or nested query
 => one query is called inner query and other query is called outer query
 => first inner query is executed then outer query
 => output of inner query is input to outer query
 => use subquery when where cond based on unknown value 

  Types of subqueries :- 
  -----------------------------

  1 single-row subqueries
  2 multirow subqueries
  3 co-related subqueries
  4 derived tables & CTEs
  5 scalar subqueries 

 single-row subqueries :-  
 -------------------------------
 
 => if subquery returns one value then it is called single row subquery

  SELECT columns
  FROM tabname
  WHERE colname OP (SELECT STATEMENT)

 => OP must be any  relational operator like  =    >      <     <>    

  examples :- 

  => employees earning more than blake ?

      SELECT *
      FROM emp 
      WHERE sal >  (SELECT sal FROM emp WHERE ename='blake')

 => employees who are senior to king ?

     SELECT *
     FROM emp 
     WHERE hiredate <   (
                                       SELECT hiredate
                                       FROM emp 
                                       WHERE ename='king' 
                                       )

=> display name of the employee earning max salary ?
 
    SELECT ename
    FROM emp 
    WHERE sal = MAX(sal)  => ERROR

   NOTE :-  aggregate functions not allowed in where clause and they are
   allowed in select,having clauses.

    SELECT ename
    FROM emp 
    WHERE sal = (SELECT MAX(sal) FROM emp)
                           -----------------------------------------
                                   5500
   
=> name of the employee having max experience ?

    SELECT ename
    FROM emp 
    WHERE hiredate = (SELECT MIN(hiredate) FROM emp)

=> display 2nd max salary ?

     SAL
     1000
      3000
      2000
      1500
      5000

    SELECT MAX(sal)
    FROM emp 
    WHERE sal < (SELECT MAX(sal) FROM emp)

=> name of the employee earning 2nd max sal ? 

   SELECT ename
   FROM emp 
  WHERE sal = (
                        SELECT MAX(sal)
                        FROM emp 
                        WHERE sal < (SELECT MAX(sal) 
                                               FROM emp))

28-apr-23

 => delete the employee having max experience ?

     DELETE 
     FROM EMP 
     WHERE HIREDATE = (SELECT MIN(HIREDATE) FROM EMP)

 => swap employee salaries whose empno = 7369,7499 ?

     before swap                 after swap
    
     7369   1150	         7369   1920
     7499   1920	         7499   1150
 
    UPDATE EMP
    SET SAL =  CASE EMPNO
                       WHEN 7369 THEN (SELECT SAL FROM EMP WHERE EMPNO=7499)
                       WHEN 7499 THEN (SELECT SAL FROM EMP WHERE EMPNO=7369)
                       END
   WHERE EMPNO IN (7369,7499)


  UPDATE EMP
    SET SAL =  CASE EMPNO
                       WHEN 7369 THEN 1920
                       WHEN 7499 THEN 1150
                       END
 WHERE EMPNO IN (7369,7499)

 SUBQUERY VS JOIN :- 
--------------------------------

1  display employees working at NEW YORK loc ?

  join :-
  --------

    SELECT E.*
    FROM EMP AS E INNER JOIN DEPT AS D
         ON E.DEPTNO = D.DEPTNO
   WHERE D.LOC = 'NEW YORK' 

   subquery :- 

    SELECT *
    FROM EMP 
    WHERE DEPTNO =  (SELECT DEPTNO 
                                      FROM DEPT 
                                      WHERE LOC='NEW YORK')

2  display employee details with dept details working at NEW YORK loc ?

  join :- 
 --------
  
   SELECT E.*,D.*
      FROM EMP AS E INNER JOIN DEPT AS D
         ON E.DEPTNO = D.DEPTNO
   WHERE D.LOC = 'NEW YORK' 

 subquery :- 
 ----------------

  not possible 


 =>  to display data from one table and conditiion based on another table
       then we can use join or subquery.

 => to display data from two tables then use join operation.

 Multirow subqueries :- 
 ------------------------------

  =>  if subquery returns multiple values then it is called multirow subquery

   SELECT COLUMNS
   FROM TABNAME
   WHERE  COLNAME   OP   (SELECT STATEMENT)

 => OP must be IN ,NOT IN ,ANY,ALL

           single                      multi

            =                             IN

            <>                          NOT IN

             >                           >ANY   >ALL

             <                          <ANY   <ALL


 =>  employees working at NEW YORK,CHICAGO locations ?

      SELECT *
      FROM EMP
      WHERE DEPTNO IN (SELECT DEPTNO
                                         FROM DEPT
                                         WHERE LOC IN ('NEW YORK','CHICAGO'))

 ANY operator :-
------------------------

     WHERE   X  >  ANY(1000,2000,3000)

         IF X=800       FALSE
             X=1500     TRUE
             X=4500     TRUE

    WHERE  X <  ANY(1000,2000,3000)

      IF X=800   TRUE
          X=1500  TRUE
          X=4500  FALSE

 ALL :- 
 ---------

   WHERE X > ALL(1000,2000,3000)

      IF X=800      FALSE
          X=1500    FALSE
          X=4500   TRUE

  WHERE  X  < ALL(1000,2000,3000)

    IF  X = 800   TRUE
               1500  FALSE
               4500 FALSE

=> employees earning more than all managers ?

    SELECT *
    FROM EMP
    WHERE SAL > ALL (SELECT SAL FROM EMP WHERE JOB='MANAGER')

=> employees earning more than atleast one manager ?

    SELECT *
    FROM EMP
    WHERE SAL > ANY (SELECT SAL FROM EMP WHERE JOB='MANAGER')

co-related subqueries :-
-------------------------------

 => if inner query references values of outer query then it is called co-related subquery

 => in co-related subquery execution starts from outer query and inner query
     is executed no of times depends on no of rows returns by outer query

 => use co-related subquery to execute subquery for each row return by outer query

 example 1 :- 

  EMP
  EMPNO  ENAME  SAL    DEPTNO
  1            A             3000  10
  2           B              5000  20
  3           C              4000  30
  4           D              2000  20
  5           E              6000  10

=> employees earing more than avg(sal) of their dept ?

   SELECT *
   FROM EMP AS X
   WHERE SAL > (SELECT AVG(SAL) 
                            FROM EMP 
                             WHERE DEPTNO = X.DEPTNO)

  1            A               3000  10        3000 > (4500)    FALSE
  2            B              5000   20        5000 > (3500)   TRUE
  3            C              4000   30        4000 > (4000)   FALSE
  4            D              2000   20        2000 > (3500)   FALSE
  5            E              6000   10        6000 > (4500)   TRUE

29-APR-23

 => display employees earning max salary in their dept ? 

    SELECT *
    FROM EMP AS X
    WHERE SAL = (SELECT MAX(SAL)
                             FROM EMP
                             WHERE DEPTNO = X.DEPTNO) 

  1            A             3000  10      3000 = (6000)   FALSE
  2           B              5000  20      5000 = (5000)  TRUE
  3           C              4000  30      4000 = (4000)  TRUE
  4           D              2000  20      2000 = (5000)  FALSE
  5           E              6000  10      6000 = (6000)  TRUE

=> display top 3 max salaries ?

    SAL
    5000
    1000
    3000
    2000
    4000

    SELECT DISTINCT A.SAL
    FROM EMP AS A
    WHERE 3 >  (SELECT COUNT(DISTINCT B.SAL)
                          FROM EMP AS B
                          WHERE A.SAL < B.SAL)
    ORDER BY SAL DESC

    EMP A            EMP B
    SAL                SAL
    5000               5000            3 > (0)   TRUE
    1000               1000            3 > (4)   FALSE
    3000               3000            3 > (2)   TRUE
    2000               2000            3 > (3)   FALSE
    4000               4000            3 > (1)   TRUE


 => display 5th max salary ?
 
    SELECT DISTINCT A.SAL
    FROM EMP AS A
    WHERE (5-1) =   (SELECT COUNT(DISTINCT B.SAL)
                                FROM EMP AS B
                                WHERE A.SAL < B.SAL)
    ORDER BY SAL DESC

EXISTS operator :- 
--------------------------

 => operator used to find whether record exists in the table or not 

    SELECT 
    FROM 
    WHERE EXISTS (SELECT STATEMENT)

 =>   EXISTS returns true / false 

         TRUE  =>  if subquery returns atleast one row
         FALSE => if subquery returns 0 rows 

    WHERE NOT EXISTS (SELECT STATEMENT)

       TRUE       =>  if subquery returns 0 rows
       FALSE      => if subquery returns atleast one row

example :- 

 EMP                                          DEPT
 empno ename  deptno              deptno   dname    loc
1           A           10                   10          ACCTS
2           B           20                   20         RESEARCH
3           C           30                   30         SALES
                                                 40         OPERATIONS

 => display departments which are not empty ?

   SELECT *
   FROM DEPT AS D
   WHERE EXISTS (SELECT * FROM EMP WHERE DEPTNO = D.DEPTNO)

  10	ACCOUNTS
  20	RESEARCH 
  30	SALES

  SELECT *
  FROM DEPT
  WHERE DEPTNO IN (SELECT DEPTNO FROM EMP)
                                      10
                                      20
                                      30
                             
 sql server recommends use EXISTS operator than IN operator
 because EXISTS gives good performance than IN operator.

=> display departments which are empty ?

   SELECT *
   FROM DEPT AS D
   WHERE NOT EXISTS (SELECT * 
                                       FROM EMP 
                                       WHERE DEPTNO = D.DEPTNO)
 
   40	OPERATIONS

  SELECT *
  FROM DEPT  
  WHERE DEPTNO NOT IN (SELECT DEPTNO FROM EMP)
                                               10
                                                20
                                                30
                                          
sql server recommends NOT EXISTS operator than NOT IN operator

example 2 :- 

 orders                                            customers
 ordid   orddt  deldt   cid                  cid     name     addr
 1000                       10                  10
 1001                       11                  11
 1002                       10                  12

=> list of customers not placed any order ?

=> list of customers placed orders ?

Derived tables :- 
-----------------------

 => subqueries in from clause are called derived tables.

    SELECT columns
    FROM (SELECT STATEMENT)  AS <ALIAS>
    WHERE COND

 => subquery output acts like a table for outer query

=>  use derived tables to control order of execution of clauses 

=>  by default sql server executes the clauses in the following order

     FROM
     WHERE
     GROUP BY
     HAVING
     SELECT
     ORDER BY 

 => use derived tables to control this order of execution.

 example 1 :- 

 => display ranks of the employees based on sal and highest paid employee
      should get 1st rank ?

        SELECT ENAME,SAL,
              DENSE_RANK() OVER (ORDER BY SAL DESC) AS RNK
         FROM EMP 

     above query returns ranks of all the employees but to display
     top 5 employees apply where condition
 
        SELECT ENAME,SAL,
             DENSE_RANK() OVER (ORDER BY SAL DESC) AS RNK
        FROM EMP 
        WHERE RNK <=5    => ERROR

       column alias cannot be used in where clause because where clause
       is executed before select  , to overcome this problem use derived table

       SELECT *
       FROM (SELECT ENAME,SAL,
                           DENSE_RANK() OVER (ORDER BY SAL DESC) AS RNK
                  FROM EMP) AS E 
       WHERE RNK<=5 


     01-MAY-23
 
   => display top 5 max salaries ?
 
         SELECT DISTINCT SAL
         FROM (SELECT ENAME,SAL,
        		 DENSE_RANK() OVER (ORDER BY SAL DESC) AS RNK
     	     FROM EMP) AS E  
         WHERE RNK<=5
         ORDER BY SAL DESC

  => display 5th max salary ?

      WHERE RNK=5 

 Example 2 :- 

 => display first 5 rows from emp table ?
 
  SELECT *
  FROM ( SELECT ROW_NUMBER() OVER (ORDER BY EMPNO ASC) AS RNO,
                             EMPNO,ENAME,SAL 
               FROM EMP ) AS E
  WHERE RNO<=5 

  WHERE RNO = 5 

  WHERE  RNO  IN (5,7,11) 
 
  WHERE RNO BETWEEN 5 AND 10 

  WHERE RNO%2=0

  => display last 3 rows from emp table ?
 
   SELECT *
   FROM ( SELECT ROW_NUMBER() OVER (ORDER BY EMPNO ASC) AS RNO,
                        EMPNO,ENAME,SAL 
               FROM EMP ) AS E
  WHERE RNO >= (SELECT COUNT(*)-2 FROM EMP)

 => delete first 3 rows from emp table ?

      DELETE 
      FROM (SELECT ROW_NUMBER() OVER (ORDER BY EMPNO ASC) AS RNO,
                     EMPNO,ENAME,SAL 
                 FROM EMP ) AS E
      WHERE RNO <= 3    => ERROR

    in derived table  outer query cannot be DML and it must be SELECT statement,
    to  overcome this use CTEs

 CTE :- 
 ----------

  =>  CTE stands for comman table expression 
  =>  it is a named query and we can reference that name in another query like select/insert/update/delete.
  =>  in derived tables outer query cannot be DML and in CTEs outer query can be DML.

  WITH <NAME> 
  AS
      (SELECT  STATEMENT)

  SELECT/INSERT/UPDATE/DELETE

  Example 1 :- 

  => delete first 3 rows from emp ?

 WITH E
  AS
  (SELECT ROW_NUMBER() OVER (ORDER BY EMPNO ASC) AS RNO,
          EMPNO,ENAME,SAL 
  FROM EMP) 
 DELETE FROM E WHERE RNO<=3
 
Example 2 :- 

 => delete duplicate records ? 

  EMP44
  ENO	ENAME	SAL
  1	A	5000
  2	B	3000
  1	A	5000   => duplicate row
  2	B	3000  =>  duplicate row
  3	C	6000

 STEP 1 :-  generating row numbers with group (eno,ename,sal)

 SELECT ENO,ENAME,SAL,
                ROW_NUMBER() OVER (PARTITION BY ENO,ENAME,SAL
                                                         ORDER BY ENO ASC) AS RNO
 FROM EMP44

1	A	5000	1
1	A	5000	2

2	B	3000	1	
2	B	3000	2

3	C	6000	1


STEP 2 :-  now delete the records whose rno > 1 

WITH E 
 AS
   (SELECT ENO,ENAME,SAL,
                ROW_NUMBER() OVER (PARTITION BY ENO,ENAME,SAL
                                                         ORDER BY ENO ASC) AS RNO
 FROM EMP44)
DELETE FROM E WHERE RNO>1 

 
Assignment :- 
-------------------

1

  T1
  AMT
  1000
  -3000
  5000
  -1500
 4000
 -2000

 output :- 

 
   POS	NEG
   1000	-3000
   5000	-1500
   4000	-2000

2

    T1		T2
    F1		C1
    1		A
    2		B	
    3		C

  output :- 

  1	A
  2	B
  3	C

scalar subqueries :- 
--------------------------

 =>  subqueries in select clause are called scalar subqueires

       SELECT (select stmt) , (select stmt),-----------
       FROM tabname
       WHERE condition

 => subquery output acts like a column for outer query.

 => use scalar subquery to show the query output in seperate column.

 example 1 :- 

SELECT (SELECT COUNT(*) FROM EMP) AS EMP,
              (SELECT COUNT(*) FROM DEPT) AS DEPT

    EMP   DEPT
    11	4
 
example 2 :- 

 display dept wise total salary ?

 SELECT deptno,SUM(sal) as dept_totsal
 FROM emp 
 GROUP BY deptno 

10	8750.00
20	10075.00
30	6550.00

display  deptno	dept_totsal	totsal  ?

  SELECT deptno,
                SUM(sal) as dept_totsal,
               (SELECT SUM(sal) FROM emp) as totsal
 FROM emp 
 GROUP BY deptno 

 10	8750.00	25375.00
 20	10075.00	25375.00
 30	6550.00	25375.00

 => display   deptno	   dept_totsal	totsal	pct ?

     pct = (dept_totsal/totsal)*100

    SELECT deptno,SUM(sal) as dept_totsal,
                  (SELECT SUM(sal) FROM emp) as totsal,
                 (SUM(sal)/(SELECT SUM(sal) FROM emp))*100 as pct
     FROM emp
     GROUP BY deptno


 summary :-

 importance of subqueries
 types of subqueries
 single row ,multi row subqueries
 co-related subqueries
 derived tables
 CTEs
 scalar subqueres
                   
 02-MAY-23

 creating a new table from existing table (replica)   :- 
 --------------------------------------------------------------

 SELECT COLUMNS  INTO  <NEW-TABNAME> 
 FROM <OLD-TABNAME>
 WHERE COND

 Example  1   :- (copying complete table)

 SELECT * INTO EMP22  FROM EMP

example 2 :-   copying specific rows & columns

 SELECT EMPNO,ENAME,JOB,SAL  INTO  EMP33
 FROM EMP
 WHERE JOB IN ('CLERK','MANAGER') 

 example 3 :- copy only columns (structure) but not rows (data)

 SELECT * INTO EMP44
 FROM EMP 
 WHERE 1=2 

MERGE command :-
---------------------------

  => used to merge data into a table.
 =>  merge is the combination of insert & update & delete.
 =>  used to manage replicas.
 =>  using merge command we can apply changes made to one table to another table.
 =>  used in ETL applications 
 
             E  => Extract
             T  => Transform
             L  =>  Load 

syntax :- 
 
 MERGE INTO <TARGET-TABLE>  AS  <ALIAS> 
 USING <SOURCE-TABLE> AS <ALIAS>
  ON  (CONDITION)
 WHEN MATCHED THEN
        UPDATE
 WHEN NOT MATCHED THEN
       INSERT
 WHEN NOT MATCHED BY SOURCE THEN
       DELETE ;

Example :- 

step 1 :-  create source table

 CREATE TABLE custs 
 ( 
  cid  INT,cname VARCHAR(10),caddr  VARCHAR(10)
 )

 INSERT INTO custs VALUES(10,'A','HYD'),(11,'B','MUM')

 CUSTS
 CID	CNAME	CADDR
 10	A	HYD
 11	B	MUM

 step 2 :-  create replica

 SELECT * INTO CUSTT FROM CUSTS 

 CUSTT
 CID	CNAME	CADDR
 10	A	HYD
 11	B	MUM

step 3 :- make changes to source table
 
 INSERT INTO CUSTS VALUES(12,'C','DEL')

 UPDATE CUSTS SET CADDR='BLR' WHERE CID=10

 CUSTS
 CID	CNAME	CADDR
 10	A	BLR  => UPDATED
 11	B	MUM
 12	C	DEL => INSERTED

step 4 :- apply changes to target table using merge command

 MERGE INTO CUSTT AS T
 USING CUSTS AS S
 ON (S.CID = T.CID)
 WHEN MATCHED THEN
       UPDATE  SET  T.CADDR = S.CADDR 
  WHEN NOT MATCHED THEN
        INSERT VALUES (S.CID,S.CNAME,S.CADDR) 
  WHEN NOT MATCHED BY SOURCE THEN
        DELETE ; 
    
PIVOT operator :-
------------------------

=> operartor used to convert rows into columns.
=> used to display data in matrix form.
=> used for cross tabulation

syntax :- 

 SELECT  *
 FROM  (SELECT required data)  AS  <ALIAS>
 PIVOT
   (
      aggr-expr  for colname IN (v1,v2,v3,----)
   )  AS <NAME>
 ORDER BY colname ASC/DESC

 example 1 :- 
 
 		10	20	30


   analyst		?	6000	?	

   clerk		

   manager

   salesman  			5600
 
 SELECT *
 FROM  (SELECT deptno,job,sal FROM emp) AS E 
 PIVOT
   (
      SUM(sal)  FOR deptno IN ([10],[20],[30])
   ) AS PIVOT_TBL
 ORDER BY job ASC 

example 2 :- 

	1	2	3	4

 1980	?	?	?	?	

 1981
 
 1982

 1983

  SELECT *
  FROM (SELECT DATEPART(YY,HIREDATE) AS YEAR,
                            DATEPART(Q,HIREDATE) AS QRT,
                            EMPNO
             FROM EMP) AS E
  PIVOT
    (
       COUNT(EMPNO) FOR QRT IN ([1],[2],[3],[4])
   ) AS PIVOT_TBL
  ORDER BY YEAR ASC

Example 3 :- 

  STUDENT
  SNO	SNAME	SUBJECT	MARKS
  1	A	MAT		80
  1	A	PHY		70
  1	A	CHE		60 
  2	B	MAT		60
  2	B	PHY		50
  2	B	CHE		70

OUTPUT :- 
 
  SNO	SNAME	MAT	PHY	CHE
  1	A	80	70	60
  2	B	60	50	70


=====================================================================

 05-MAY-23

 DATABASE TRANSACTIONS :- 
 ----------------------------------------

 => a transaction is a unit of work that contains one or more dmls  and must be
      saved as a whole or must be cancelled as a whole.

  ex :-     money transfer

              acct1-----------------1000---------------------->acct2

              update1                                                     update2
             (bal=bal-1000)                                            (bal=bal+1000)

               succcessful                                             successful                   valid
               failed                                                       failed                            valid

               successful                                              failed                             invalid                         
               failed                                                      successful                     invalid

  => every transaction must gurantee a property called atomocity i.e. all or none
       if transaction contains multiple operations , if all operations are successful then
      it must be saved , if one of the operation fails then entire transaction must be cancelled.

 => the following commands provided  by sql server to control transactions called TCL 
      (Transaction Control Lang) commands

       1  COMMIT                        =>     to save transaction
       2  ROLLBACK                   =>     to cancel transaction
       3  SAVE TRANSACTION   =>     to cancel part of the transaction

  => every transaction has a begin point and an end point

 => in sql server a txn begins implicitly  when user submits DML/DDL command
      and ends implicitly with commit.

 example :- 

  UPDATE EMP SET SAL=2000 WHERE EMPNO=7499 

/*

 1  txn begins
 2  updated
 3  txn ends with commit
 
 */
 
 => a txn can also be started explicitly by using "BEGIN TRANSACTION" command
      and ends explicitly with COMMIT/ROLLBACK 	command.

    example 1 :- 

    create table a(a int)
    begin transaction                =>   txn begins T1
    insert into a values(10)
    insert into a values(20)
    insert into a values(30)
    insert into a values(40)
    commit                               =>  txn ends 

  => if txn ends with commit then it is called successful transaction and operations are saved

  example  2 :- 

    create table a(a int)
    begin transaction                =>   txn begins T1
    insert into a values(10)
    insert into a values(20)
    insert into a values(30)
    insert into a values(40)
    rollback                              => txn ends 

  => if txn ends with rollback then it is called  aborted transaction and operations are 
       cancelled

 SAVE TRANSACTION :- 
 --------------------------------

 => we can declare save transaction and we can cancel upto the save transaction.
 => using save transaction we can cancel part of the transaction.

   example :- 

    create table a(a int)
    begin transaction              
    insert into a values(10)
    insert into a values(20)
    save transaction st1
    insert into a values(30)
    insert into a values(40)
    save transaction st2 
    insert into a values(50)
    insert into a values(60)
    rollback transaction st1                          
  
     
    SELECT * FROM a  

    10
    20 

 =================================================================

  DB  SECURITY :- 
  ----------------------

  1  LOGINS                   =>   provides security at server level
  2  USERS                     =>  provides security at db level	
  3  PRIVILEGES            =>  provides security at table level
  4  VIEWS                     =>  provides security at row & col level

  SERVER  (login)
         DATABASE (user)
                      TABLE (privileges)
                               ROWs & COLs (views)

 

DATA
=> in object explorer

      select security =>  logins => New login 

 1      Enter Login Name :-  NARESH

 2      select SQL SERVER Authentication

 3      enter password  :-  123

         confirm password :- 123

 4      uncheck user must change password at next login

    click OK 

 command to create new login :- 
 ----------------------------------------

 USE [master]
GO
CREATE LOGIN [NARESH] WITH PASSWORD='123'
GO


NOTE :-  using this login NARESH can connect to server but cannot access database,
to access database NARESH must be associated with a user in database.

 creating user in database :- 
 -----------------------------------

 => open the db in which you want to create user

      DB6PM
               SECURITY
                          USERS  => NEW USER

 => Enter username :-  VIJAY
      Enter loginname :-  NARESH
      
 => click ok

 => login NARESH associated with user VIJAY in db DB6PM

command to create user :- 
----------------------------------

USE [DB6PM]
GO
CREATE USER [VIJAY] FOR LOGIN [NARESH]
GO

 
LOGIN
    SA 
    NARESH

 DB6PM
        DBO (SA)
               EMP
               DEPT
               STUDENT
               CUST
        VIJAY(NARESH)
 
 PRIVILEGES :- 
 --------------------

  => privileges means permissions
  => permissions are granted by user by using grant command

 syn :-  GRANT <privileges> ON <tabname> TO <username>

 ex :-    

 DBO :- 
 -----------
 
 GRANT  SELECT,INSERT,UPDATE,DELETE ON EMP TO VIJAY 

VIJAY :-
----------

 1  SELECT * FROM EMP 

 2  UPDATE EMP SET SAL=2000 WHERE EMPNO=7369

 NOTE :-  changes made by one user visible to another user after commit.

REVOKE command :- 
----------------------------

=>  command used to take back permissions from user.

 syn :-  REVOKE <privileges> ON <tabname> FROM <username> 

 ex :- 

 DBO  :- 
 ----------

 REVOKE SELECT,INSERT,UPDATE,DELETE ON EMP FROM VIJAY 

 VIJAY :- 
 ------------

 SELECT * FROM EMP   => ERROR

============================================================

DB objects :-
-------------------

 TABLES
 VIEWS
 SYNONYMS
 SEQUENCES
 INDEXES

 STORED PROCEDURES
 FUNCTIONS
 TRIGGERS 

 VIEWS :- 
 -------------

 => a view is a subset of a table.
 
 => a view is a virtual table because it doesn't store data and doesn't occupy
      memory and it always derives data from base table.

 => a view always represents a query 

 => views are created 

      1  to provide security
      2  to reduce complexity

 => with the help of views we can grant specific columns and rows to users.

 => views are 2 types 
 
  1  simple views
  2  complex views 
 
 simple views :- 
 ---------------------

 => if view created on single table then it is called simple view.

     CREATE VIEW <NAME>
     AS
     SELECT  STATEMENT 

 Ex :- 

  CREATE VIEW V1
  AS
  SELECT EMPNO,ENAME,JOB,DEPTNO FROM EMP 

 => sql server creates view "V1"  and stores query but not query output
      
    SELECT * FROM V1  
     
 => when above query send to sql server , it rewrite the query as follows

    SELECT * FROM 
                (SELECT EMPNO,ENAME,JOB,DEPTNO FROM EMP)

 Granting permissions on view to user :- 
 ----------------------------------------------------

 DBO :- 
 -----------

  GRANT SELECT,INSERT,UPDATE,DELETE ON V1 TO VIJAY

 VIJAY :- 
 ------------

 1    SELECT  * FROM V1 

 2    INSERT INTO V1 VALUES(777,'KKK','CLERK',20)

 3    UPDATE V1 SET JOB='MANAGER' WHERE EMPNO=777

 4     UPDATE V1 SET SAL=3000  WHERE EMPNO=777 => ERROR

 ROW LEVEL SECURITY :- 
 -----------------------------------

  CREATE VIEW V2
  AS
  SELECT EMPNO,ENAME,JOB,DEPTNO
  FROM EMP
  WHERE DEPTNO = 20 

  GRANT SELECT,INSERT,UPDATE,DELETE ON V2 TO VIJAY 

 VIJAY :-  
 -----------

  INSERT INTO V2 VALUES(444,'PQR','CLERK',30) => 1 ROW AFFECTED

  above insert command executed successfully even though it is violating
  where condition

 WITH CHECK OPTION :- 
 ---------------------------------

 => if view created with "WITH CHECK OPTION" then any DML command
      through view violates where condition  that DML is not accepted.

  CREATE VIEW V3
  AS
  SELECT EMPNO,ENAME,JOB,DEPTNO
  FROM EMP
  WHERE DEPTNO = 20 
  WITH CHECK OPTION 

  VIJAY :- 
  ----------

 INSERT INTO V3 VALUES(555,'KLM','CLERK',30)  => ERROR

 COMPLEX VIEWS :-
 ---------------------------

 => a view said to be complex view 

     1 if based on multiple tables
     2 if query contains group by clause
                                  distinct clause
                                  aggregate functions
                                  set operators
                                  subqueries 

  => with the help of views complex queries can be converted into simple queries

   Ex 1 :- 

   CREATE VIEW CV1
   AS
   SELECT E.EMPNO,E.ENAME,E.SAL,
                 D.DEPTNO,D.DNAME,D.LOC
   FROM  EMP AS E INNER JOIN DEPT AS D
       ON   E.DEPTNO = D.DEPTNO 

 => after creating view whenever user want data from emp & dept tables
      instead of writing join query write the simple query as follows

       SELECT * FROM CV1 

 Ex 2 :- 

  CREATE VIEW CV2
  AS
   SELECT D.DNAME,
                  MIN(E.SAL) AS MINSAL,
	  MAX(E.SAL) AS MAXSAL,
	  SUM(E.SAL) AS TOTSAL,
	  COUNT(*) AS CNT
   FROM EMP AS E INNER JOIN DEPT AS D
        ON E.DEPTNO = D.DEPTNO
  GROUP BY D.DNAME

=> after creating whenever we want dept wise summary execute the 
     following query

   SELECT * FROM CV2 

   difference between simple and complex views ?

            SIMPLE                            COMPLEX 

 1   based on single table              based on multiple tables 

 2   performs simple operations    performs complex operations 
                                                    like joins,group by ,aggregate etc

 3   always updatable                   not updatable i.e. doesn't allow dmls
       i.e. allows dml

=> display list of tables created by user ?

      SELECT * FROM  INFORMATION_SCHEMA.TABLES 

=> display list of views created by user ? 

    SELECT * FROM INFORMATION_SCHEMA.VIEWS

Droping :- 
------------

   DROP VIEW  V1 

=> if we drop table what about views created on table ?

   ans :-  views  are  not dropped but cannot run the queries on view

WITH SCHEMABINDING :- 
------------------------------------

 => if created with "WITH SCHEMABINDING" then sql server will not allow
      user to drop table if any view exists on the table.

  Rules :- 

  1  "*" is not allowed in select clause
  2  tablename should be prefixed with schema name

  Ex :- 
 
 CREATE VIEW V10
 WITH SCHEMABINDING
 AS
 SELECT DEPTNO,DNAME,LOC FROM DBO.DEPT 


  DROP TABLE DEPT   => ERROR

08-may-23

SYNONYMS :-
-------------------

=> a synonym is another name or alternative name for a table or view.

=> if tablename is lengthy then we can give a simple and short name to the table 
     called synonym and instead of using tablename we can use synonym name
     in select/insert/update/delete queries.

 syn :-  CREATE SYNONYM <NAME> FOR <TABNAME>

 ex :-    CREATE SYNONYM E FOR EMP 

=> after creating synonym instead of using tablename use synonym name 
     in select/insert/update/delete queries

1     SELECT  *  FROM E 
 
2     UPDATE E SET SAL = 2000 WHERE EMPNO = 7844 

   difference between alias and synonym ?

       synonym			alias

 1   permanent                                         not permanent

  2  stored in db                                        not stored in db 

  3  scope of the synonym is                     scope of the alias is 
      upto the schema  	                upto the query in which
                                                                it is declared

=> display list of synonyms ?

     SELECT name,base_object_name FROM SYS.SYNONYMS 
 
Droping synonym :-
--------------------------

  DROP SYNONYM  E 

============================================================

SEQUENCES :-
---------------------

=>  sequence is also a db object created to generate sequence numbers. 
=>  created to auto increment column values.

 syn :-   

   CREATE SEQUENCE <NAME>
   [START WITH <VALUE>]
   [INCREMENT BY <VALUE>]
   [MAXVALUE <VALUE>]
   [MINVALUE <VALUE>]
   [CYCLE/NOCYCLE]
   [CACHE <SIZE>]

  Example 1 :- 

  CREATE SEQUENCE S1
  START WITH 1
  INCREMENT BY 1
  MAXVALUE 5 

 using sequence :- 
 -----------------------

 CREATE TABLE student
 (
    sid  INT ,
    sname VARCHAR(10)
  )

  INSERT INTO student VALUES(next value for s1,'A')
  INSERT INTO student VALUES(next value for s1,'B')
  INSERT INTO student VALUES(next value for s1,'C')
  INSERT INTO student VALUES(next value for s1,'D')
  INSERT INTO student VALUES(next value for s1,'E')
  INSERT INTO student VALUES(next value for s1,'F')  => ERROR

        SELECT * FROM STUDENT 
   
	1	A
	2	B
	3	C
	4	D
	5	E
 
 Example 2 :- 

  CREATE SEQUENCE S2
  START WITH 100
  INCREMENT BY 1
  MAXVALUE 999

 => use above sequence to generate empno ?

   UPDATE EMP SET EMPNO = NEXT VALUE FOR S2
  
Example 3 :- 

INVOICE
INVNO         	INVDT
NIT/0523/1	???	
NIT/0523/2	???

CREATE TABLE INVOICE
(
   INVNO    VARCHAR(20),
   INVDT     DATE
)

CREATE SEQUENCE S3
START WITH 1
INCREMENT BY 1
MAXVALUE 999

=> use above sequence to generate invno ?

INSERT INTO INVOICE
     VALUES('NIT/' + format(getdate(),'MMyy') +'/' +
                    CAST(NEXT VALUE FOR S3 AS VARCHAR),GETDATE())

How to restart sequence :-
-----------------------------------

 ALTER SEQUENCE S3 RESTART WITH 1 

NOCYCLE/CYCLE :- 
----------------------------

 => by default sequence is created with NOCYCLE.

 => if sequence created with NOCYCLE then it starts from start with
      and generates upto max and after reaching max then it stops

=> if sequence created with CYCLE then it starts from start with and
     generates upto max and after reaching max then it will be reset to min

example :- 

 CREATE SEQUENCE S4
 START WITH 1
 INCREMENT BY 1
 MAXVALUE 5
 MINVALUE 1
 CYCLE
 CACHE 4 

 cache 100 :- 
 -----------------

 => sql server preallocates next 100 values in cache memory and everytime
      we call " next value for sequence " then sql server goes to cache memory
      and returns sequence next value and accessing cache memory is
      faster than accessing db  , so this improves performance.

=>  display list of sequences created by user ?
 
     SELECT  * FROM INFORMATION_SCHEMA.SEQUENCES 

Droping sequence :-
--------------------------

  DROP  SEQUENCE S1 

09-MAY-23 

  INDEXES :- 
  ----------------

  =>  index is also a db object  created to improve the performance of data accessing
  
  => index in db is similar to index in textbook , in textbook using index 
       a particular topic can be located fastly , in db using index a particular
       record can be located fastly.

 => indexes are created on columns and that column is called index key.

 => indexes are created on 

     1  columns that are frequently accessed in where clause.
     2  columns that are used in join operation.

 Types of Indexes :- 
 -------------------------

 1   Non Clustered Indexes
 2   Clustered Indexes 

Non Clustered  simple index :- 
-----------------------------------------

 => if index created on single column then it is called simple index 

  syn :-  CREATE INDEX <NAME> ON <TABNAME>(COLNAME) 

  EX :-  CREATE INDEX I1 ON EMP(SAL) 

  EMP			    3000
  SAL
 3000
 1000                           2000                                 4000
 2500
 4000               1000 *            2500 *            4000 *               5000 *
 3000               1500 *            3000 *,*
 1500               2000 *
 5000
 2000
 
   SELECT * FROM EMP WHERE SAL = 3000        (INDEX)
   SELECT * FROM EMP WHERE SAL >= 3000      (INDEX)
   SELECT * FROM EMP WHERE SAL <= 3000      (INDEX)

   SELECT * FROM EMP                                              (TABLE)
   SELECT * FROM EMP WHERE ENAME='BLAKE'     (TABLE)

 unique index :- 
 --------------------

  => unique index doesn't allow duplicate values into the column on which 
       index is created 

 ex :-  CREATE UNIQUE  INDEX  I2 ON EMP(ENAME) 

                                                K

                             G                                         Q

      ADAMS *                JAMES *          MARTIN *         SCOTT *
      ALLEN *                 JONES *          MILLER *          SMITH *
      BLAKE *
                                
     SELECT * FROM EMP WHERE ENAME = 'BLAKE' 

     INSERT INTO EMP(EMPNO,ENAME,SAL) VALUES(777,'BLAKE',4000) => ERROR

 NOTE :- 

  => primary key / unique columns are  implicitly indexed by sql server
      and  a unique index is created on primary key / unique columns 
      and unique index doesn't allow duplicates and primary key also
      doesn't allow duplicates.

 CLUSTERED INDEXES :- 
 ----------------------------------

 =>  a non clustered index stores pointers to actual records where as 
       clustered index stores actual records.

 => in clustered index order of the records in index is same as order of 
      the records in in table.

   Example :- 
 
      CREATE TABLE cust
       (
           CID   INT,
           NAME  VARCHAR(10)
       )

      CREATE CLUSTERED INDEX I10 ON CUST(CID)

      INSERT INTO CUST VALUES(10,'A')
      INSERT INTO CUST VALUES(80,'B')
      INSERT INTO CUST VALUES(40,'C')
      INSERT INTO CUST VALUES(60,'D')

                                           50

                      30                                      70
         
       10   A               40  C                 60  D              80  B

 
     SELECT * FROM CUST WHERE CID = 60  

 NOTE :- 
 
 => only one clustered index is allowed per table
 => sql server creates clustered index on primary key column

 difference between non clusterd and clustered index ?

             non clustered                          clustered 

 1        stores pointers to                     stores actual records
           actual records

 2        order of the records                  order of the records in index
          in table and index is                  and table is same
           not same
 
 3        needs extra storage                 doesn't need extra storage

 4        requires two lookups                requires one lookup to find record
           to find record

 5        maximum 999 non                   only one clustered index is 
           clustered indexes                     allowed per table
           allowed per table


 6      sql server implicitly                     sql server implicitly creates
         creates non clustered                 clustered index on primary key
         index on unique columns           columns

 how many indexes created on table ?

  ans :-  1000

 list of indexes  ?

  sp_helpindex emp 

 Droping index :- 
 ---------------------

 drop index emp.i1 

  SERVER
         DATABASE
                   TABLES
                             ROWS & COLS
                             CONSTRAINTS
                             INDEXES
                             TRIGGERS
                   VIEWS
                   SYNONYMS
                   SEQUENCES
                   PROCEDURES
                   FUNCTIONS
         
SCHEMA :- 
---------------

 => SCHEMA is group of objects like tables,views,sequences,indexes etc.
 => related objects can be grouped into one schema.
 
 syn :-  CREATE SCHEMA  <NAME> 

 ex :-   CREATE SCHEMA  SALES

CREATING TABLE IN SCHEMA :-
 --------------------------------------------

CREATE TABLE SALES.CUST
(
  CID  INT,
  CNAME VARCHAR(10)
 )

what is default schema ?

  ans :- DBO 

list of predefined schemas ?

  1  DBO
  2  INFORMATION_SCHEMA 
  3  SYS


 INFORMTION_SCHEMA.TABLES                          =>   stores informtion about tables
                                       .COLUMNS                      =>   stores information about columns
                                       .TABLE_CONSTRAINTS  =>   stores informtion about constraints
                                       .TABLE_PRIVILEGES      =>   stores information about privileges granted to users
                                       .VIEWS                           =>    stores information about views
                                       .SEQUENCES                 =>    stores information about sequence


=====================================================================================

 			 T-SQL PROGRAMMING (TRANSACT-SQL)
                                                ----------------------------------------------------------
   
  
    basic db programming     
    conditional statements
    loops
    cursors
    error handling
    stored procedures
    functions
    triggers
    dynamic sql

   Features :- 
   ----------------
  
  1 improves performance :- 
     ----------------------------------

   => in T-SQL ,  sql commands can be grouped into one block and we submit that
        block to server , so in T-SQL  no of requests and response between user
        and server are reduced  so performance is improved.
 
 2  supports conditional statements ;- 
   -------------------------------------------------

 => in T-SQL , sql commands can be executed based on conditions

3 supports loops :- 
  -----------------------

 => T-SQL supports looping statements like while , using loops we can execute
      sql commands repeatedly multiple times.

4  supports error handling :- 
 --------------------------------------

 => in T-SQL , if any statement causes error then we can handle that error and
      we can replace system generated message with our own simple and user 
      friendly message.

5   supports reusability :- 
 ----------------------------------

  => T-SQL programs can be stored in db and applications which are connected
        to db can reuse these programs.

 => T-SQL programs are 2 types 

   1  Anonymous Blocks
   2  Named Blocks 
                stored procedures
                functions
                triggers 

 Anonymous Blocks :- 
 ------------------------------
  
=>  a block without name is called anonymous block
 => the following stmts are used in T-SQL programming

    1  DECLARE
    2  SET
    3  PRINT 

 DECLARE statement :- 
 -------------------------------

 => used to declare variables

     syn :-  DECLARE  @varname    datatype(size)
 
     ex :-    DECLARE @x   INT
                DECLARE @s   VARCHAR(10)
                DECLARE @d   DATE
 
                DECLARE  @x INT,@s  VARCHAR(10),@d  DATE

 SET statement :- 
 ----------------------

   => used to assign value to variable

               SET @varname =  value

     ex :-   SET @x = 100
               SET @s = 'abc'
               SET @d =  GETDATE()

 PRINT statement :- 
 ----------------------------

  => used to print messages or variable values

           PRINT   message / @varname

   ex :-      PRINT  'hello'
                PRINT @x
               
 Example 1 :- 
 
 DECLARE @a int,@b int,@c int
 SET @a=100
 SET @b=200
 SET @c = @a+@b 
 PRINT @c

Example 2 :-  write a prog to input date and print day of the week 

   DECLARE @d  DATE 
   SET @d =  '2023-01-01'
   PRINT DATENAME(DW,@d) 

DB programming with T-SQL :- 
-------------------------------------------

 => to perform operations on db execute SQL commands from T-SQL program.
 => the following commands can be executed from T-SQL program.

 1  DML (insert,update,delete,merge)
 2  DQL (select)
 3  TCL  (commit,rollback,save transaction)
 
  SELECT stmt syntax :- 
  --------------------------------- 
 
  SELECT  @var1 = col1, @var2 = col2, --------
     FROM   tabname
  WHERE   condition

ex :- 

  SELECT   @n=ename,@s=sal  
  FROM emp 
  WHERE empno = 110

 => write a prog to input empno and print name and salary ?
 
      DECLARE @eno  INT,@name VARCHAR(10),@sal  MONEY
       SET @eno=110
       SELECT  @name=ename,@sal=sal  
       FROM emp 
       WHERE empno = @eno
       PRINT @name + '  ' + CAST(@sal AS VARCHAR)

 => write a prog to input empno and calculate experience ?
  
      DECLARE @eno INT,@hire  DATE,@expr INT
      SET @eno=107
      SELECT  @hire = hiredate FROM emp WHERE empno = @eno
      SET @expr = DATEDIFF(YY,@hire,GETDATE())
      PRINT CAST(@expr AS VARCHAR) + ' years' 
 
11-may-23

   conditional statements :-  
  -------------------------------------

   1  if-else
   2  multi if
   3  nested if

1  if-else :- 
 ---------------

  if cond
   begin
        statements
   end
  else
      begin
          statements 
      end

 2  multi if :-
 ---------------

   if  cond1 
     begin
           statements
     end
 else if cond2
    begin
        statements
    end
 else if cond3
     begin
           statements
     end
 else 
     begin
          statements
     end
    
3  nested if :- 
 -------------------

    if  cond 
      begin
             if   cond
                begin
                      statements
                end
            else
               begin
                     statements
               end
      end
 else
     begin
           statements
     end

=> write a prog to input empno and increment sal by specific amount and 
     after increment if sal exceeds 5000 then cancel that increment ?
 
    DECLARE @eno INT,@amt MONEY,@sal MONEY 
    SET @eno = 107
    SET @amt = 2500
     BEGIN TRANSACTION
    UPDATE emp SET sal = sal + @amt WHERE empno = @eno
    SELECT @sal = sal FROM emp WHERE empno = @eno
    IF @sal > 5000
          ROLLBACK
   ELSE
         COMMIT

 => write a prog to input empno and increment salary as follows 

     if job=clerk incr sal by 10%
               salesman          15%
               manager           20%
               others               5%

    DECLARE @eno INT ,@job VARCHAR(10),@pct INT
    SET @eno = 109
    SELECT @job=job FROM emp WHERE empno = @eno
    IF @job='CLERK'
        SET @pct=10
    ELSE IF @job='SALESMAN'
        SET @pct=15
    ELSE IF @job='MANAGER'
       SET @pct=20  
    ELSE
      SET @pct=5
    UPDATE EMP SET SAL = SAL + (SAL*@pct/100)   WHERE EMPNO = @eno       

=>  write a prog to process bank transaction (w/d) ? 

 ACCOUNTS
 ACCNO	ACTYPE	BAL 
100	S	10000
101	S	20000

  DECLARE @acno INT,@type  CHAR(1),@amt MONEY,@bal MONEY
  SET @acno=100
  SET @type='w'
  SET @amt=1000
  IF @type='w'
   BEGIN
         SELECT @bal = bal FROM accounts WHERE accno = @acno
         IF @amt > @bal 
                PRINT 'insufficient balance'
        ELSE
               UPDATE accounts SET bal = bal - @amt WHERE accno = @acno
   END
  ELSE IF @type='d'
          UPDATE accounts SET bal = bal + @amt WHERE accno = @acno
  ELSE
          PRINT 'invalid transaction type'

 => write a prog to process money transfer ?

      
     DECLARE @sacno INT,@tacno INT,@amt MONEY,@bal MONEY
     DECLARE @cnt1 INT,@cnt2 INT
     SET @sacno=100
     SET @tacno=101
     SET @amt=1000
     SELECT @bal = bal FROM accounts WHERE accno = @sacno
     IF @amt > @bal 
           PRINT 'insufficient balance'
    ELSE
        BEGIN
               BEGIN TRANSACTION
               UPDATE accounts SET bal = bal - @amt WHERE accno = @sacno
               SET @cnt1 = @@rowcount
               UPDATE accounts SET bal = bal + @amt WHERE accno = @tacno
               SET @cnt2 = @@rowcount
               IF @cnt1=1 AND @cnt2=1 
                        COMMIT 
              ELSE
                        ROLLBACK
           END

12-may-23 

 => write a prog to input sno and calculate total,avg,result and insert into result table >

   STUDENT
   SID	NAME	S1	S2	S3
   1	A	80	90	70
   2	B	30	60	50

   RESULT
   SNO	STOTAL	SAVG	SRESULT

   DECLARE @sno INT,@s1 INT,@s2 INT,@s3 INT 
   DECLARE @total INT,@avg DECIMAL(5,2),@res CHAR(4)
   SET @sno=1
   SELECT @s1=s1,@s2=s2,@s3=s3 FROM student WHERE sno = @sno
   SET @total = @s1+@s2+@s3
   SET @avg  = @total/3
   IF @s1>=35 AND @s2>=35 AND @s3>=35 
        SET @res='pass'
   ELSE
       SET @res ='fail'
   INSERT INTO RESULT VALUES(@sno,@total,@avg,@res)
 
WHILE LOOP :-
---------------------

WHILE(cond)
BEGIN
    statements
END

 if  cond = true   loop continues
 if  cond = false  loop terminates 

 => write a prog to print numbers from 1 to 20 ?

     DECLARE @x INT = 1 
     WHILE(@x<=20)
     BEGIN
            PRINT @x 
           SET @x = @x + 1
     END

 => write a prog to print 2023 calendar ?

      2023-01-01       ?
      2023-01-02       ?

      2023-12-31       ? 

     DECLARE @d1 DATE,@d2  DATE
     SET @d1 = '2023-01-01'
     SET @d2 = '2023-12-31'
     WHILE(@d1<=@d2)
     BEGIN
	PRINT CAST(@d1 AS VARCHAR) + '   ' + DATENAME(DW,@d1)
	SET @d1 = DATEADD(DD,1,@d1)
     END
           
  => write a prog to print sundays between two given dates ?

     DECLARE @d1 DATE,@d2  DATE
     SET @d1 = '2023-01-01'
     SET @d2 = '2023-12-31'
     WHILE(@d1<=@d2)
     BEGIN
	    IF  DATENAME(DW,@d1)='sunday'   
                              PRINT CAST(@d1 AS VARCHAR) + '   ' + DATENAME(DW,@d1)
                    SET @d1 = DATEADD(DD,1,@d1)
     END

 => write a prog to input string and print following pattern ?

      input :-   NARESH
 
      output :- 

        N
        A
        R
        E
        S 
        H

        DECLARE @s  VARCHAR(20),@x INT=1
        SET @s = 'NARESH'
        WHILE(@x <= LEN(@s))
        BEGIN
               PRINT SUBSTRING(@s,@x,1)
               SET @x = @x + 1
         END

 => write a prog to input string and print following pattern ?
 
     input :-  NARESH
 
     output :- 

     N
     NA
     NAR
     NARE
     NARES
     NARESH

        DECLARE @s  VARCHAR(20),@x INT=1
        SET @s = 'NARESH'
        WHILE(@x <= LEN(@s))
        BEGIN
               PRINT SUBSTRING(@s,1,@x)
               SET @x = @x + 1
         END
   
  => write a prog to input string and print reverse ?

        input    :-     NARESH

         output : -     HSERAN

       DECLARE @s  VARCHAR(10),@r VARCHAR(10)= ' ',@x INT 
      SET @s = 'NITIN'
      SET @x = LEN(@s)
      WHILE(@x>=1)
      BEGIN
          SET @r = @r + SUBSTRING(@s,@x,1)
          SET @x = @x-1
      END
      PRINT @r
      IF @s = LTRIM(@r) 
            PRINT 'palindrome'
      ELSE 
            PRINT 'not a palindrome'

 13-may-23 
 
 CURSOR :- 
 --------------

 => CURSORS are used to access row-by-row into T-SQL program.
 
 => from T-SQL program if we submit a query to sql server , it goes to db and 
      gets the data and copies that data into temporary storage and using
      cursor we can give name to that memory and access row-by-row into 
      t-sql program and process the row.

 => follow belows steps to use cursor in t-sql program

     1   DECLARE
     2   OPEN
     3   FETCH
     4   CLOSE
     5   DEALLOCATE

 DECLARING CURSOR :- 
 ---------------------------------

 syn :-  DECLARE <NAME> CURSOR FOR SELECT STATEMENT 

 ex :-    DECLARE C1 CURSOR FOR SELECT ENAME,SAL FROM EMP 

 OPENING CURSOR :- 
 -----------------------------

   syn :-   OPEN  <CURSOR-NAME>

  ex :-      OPEN  C1 

 1   select stmt submitted to sql server
 2   sql server executes the query and data returned by query is copied to cursor
 3   c1 points to cursor

FETCHING RECORDS FROM CURSOR :-
-------------------------------------------------------

 => "FETCH" stmt is used to fetch record from cursor

  syn :-  FETCH NEXT  FROM <CURSOR-NAME> INTO <VARIABLES> 

  ex :-    FETCH NEXT FROM C1 INTO @ename,@sal

 =>  a fetch stmt fetches one row at a time but to process multiple rows
       fetch stmt should be executed multiple times , so fetch stmt should
       be inside a loop.

 CLOSING CURSOR :- 
 ------------------------------

     CLOSE   C1 

 DEALLOCATE CURSOR :- 
 ------------------------------------

   DEALLOCATE C1 

@@FETCH_STATUS :- 
--------------------------------

=> system variable that returns fetch status
=> @@fetch_status returns 0 or -1 
 
    0  =>  if fetch successful
   -1  =>  if fetch unsuccessful
 
 examples :- 

  => write a prog to print all the employee names and salaries ?

      DECLARE C1 CURSOR FOR SELECT ENAME,SAL FROM EMP
      DECLARE @NAME VARCHAR(10),@SAL MONEY
      OPEN C1 
      FETCH NEXT FROM C1 INTO @NAME,@SAL
      WHILE(@@FETCH_STATUS=0)
      BEGIN
          PRINT @NAME + '    '   + CAST(@SAL AS VARCHAR)
          FETCH NEXT FROM C1 INTO @NAME,@SAL
     END
         CLOSE C1
         DEALLOCATE C1

 => write a prog to calculate total sal without using sum function ?

      DECLARE C1 CURSOR FOR SELECT SAL FROM EMP
      DECLARE @SAL MONEY,@TOTAL MONEY=0
      OPEN C1
      FETCH NEXT FROM C1 INTO @SAL
      WHILE(@@FETCH_STATUS=0)
      BEGIN
           SET @TOTAL = @TOTAL + @SAL
           FETCH NEXT FROM C1 INTO @SAL
     END
          PRINT @TOTAL
          CLOSE C1
          DEALLOCATE C1

 => write a prog to print maximum salary without using max function ?

      DECLARE C1 CURSOR FOR SELECT SAL FROM EMP
      DECLARE @SAL MONEY,@MAX MONEY = 0
      OPEN C1
      FETCH NEXT FROM C1 INTO @SAL
      WHILE(@@FETCH_STATUS=0)
      BEGIN
            IF @SAL > @MAX 
                 SET @MAX = @SAL
            FETCH NEXT FROM C1 INTO @SAL
      END
         PRINT @MAX
         CLOSE C1
         DEALLOCATE C1

 => write a prog to print minimum salary without using min function ?

      DECLARE C1 CURSOR FOR SELECT SAL FROM EMP
      DECLARE @SAL MONEY,@MIN MONEY  
      OPEN C1
      FETCH NEXT FROM C1 INTO @MIN
      WHILE(@@FETCH_STATUS=0)
      BEGIN
            FETCH NEXT FROM C1 INTO @SAL
            IF @SAL < @MIN 
                 SET @MIN=@SAL
      END
          PRINT @MIN
          CLOSE C1
          DEALLOCATE C1

15-may-23 

 => write a prog to print employee names as follows ?

            allen,ward,jones,martin,blake,-------------

    DECLARE C1 CURSOR FOR SELECT ENAME FROM EMP
    DECLARE @NAME VARCHAR(10) ,@S VARCHAR(1000)= '  '
    OPEN C1
    FETCH NEXT FROM C1 INTO @NAME
    WHILE(@@FETCH_STATUS=0)
    BEGIN
       SET @S = @S + @NAME + ','
      FETCH NEXT FROM C1 INTO @NAME
   END
        PRINT SUBSTRING(@S,1,LEN(@S)-1)
        CLOSE C1
        DEALLOCATE C1

=>  write a prog to calculate all the students total,avg,result and insert into
      result table ?

   STUDENT
   SID	NAME	S1	S2	S3
   1	A	80	90	70
   2	B	30	60	50

   RESULT
   SNO	STOTAL	SAVG	SRESULT
 
  DECLARE C1 CURSOR FOR SELECT SID,S1,S2,S3 FROM STUDENT
  DECLARE @SID INT,@S1 INT,@S2 INT,@S3 INT
  DECLARE @TOTAL INT,@AVG DECIMAL(5,2),@RES CHAR(4)
  OPEN C1
  FETCH NEXT FROM C1 INTO  @SID,@S1,@S2,@S3
  WHILE(@@FETCH_STATUS=0)
  BEGIN
       SET @TOTAL = @S1 + @S2 + @S3
       SET @AVG = @TOTAL/3.0
       IF @S1>=35 AND @S2>=35 AND @S3>=35
          SET @RES='PASS'
      ELSE
          SET @RES='FAIL'
     INSERT INTO RESULT VALUES(@SID,@TOTAL,@AVG,@RES)
     FETCH NEXT FROM C1 INTO  @SID,@S1,@S2,@S3
 END
      CLOSE C1
      DEALLOCATE C1

=> write a prog to increment employee salaries based on the pct in
     raise_salary table ?

   RAISE_SALARY
   EMPNO      PCT 
   7369           20
   7499           30
   7521           25
   7566          10
   7654          15

 SCROLLABLE CURSOR :- 
 -----------------------------------

 => by default cursor is forward only cursor and it supports forward navigation
      but doesn't support backward navigation.

 => if cursor declared with SCROLL then it is called scorllable cursor
      and scrollable cursor supports forward and backward navigation.

 => forward only cursor supports only FETCH NEXT statement
      but scrollable cursor supports the following fetch statements

       FETCH FIRST           	=>  fetches first record
       FETCH NEXT            	=>  fetches next record
       FETCH PRIOR          	=>  fetches previous record
       FETCH LAST            	=>  fetches last record
       FETCH ABSOLUTE N  	=>  fetches Nth record from first record
       FETCH RELATIVE N         =>  fetches Nth record from current record

  examples :- 

DECLARE C1 CURSOR SCROLL FOR SELECT ENAME FROM EMP 
DECLARE @NAME VARCHAR(10)
OPEN C1
FETCH FIRST FROM C1 INTO @NAME
PRINT @NAME
FETCH ABSOLUTE 5 FROM C1 INTO @NAME
PRINT @NAME
FETCH RELATIVE 5 FROM C1 INTO @NAME
PRINT @NAME
FETCH LAST FROM C1 INTO @NAME
PRINT @NAME
FETCH PRIOR FROM C1 INTO @NAME
PRINT @NAME
CLOSE C1
DEALLOCATE C1

=> write a prog to print every 5th record from emp table ?

     DECLARE C1 CURSOR SCROLL FOR SELECT ENAME FROM EMP 
     DECLARE @NAME VARCHAR(10)
     OPEN C1
     FETCH RELATIVE 5 FROM C1 INTO @NAME
     WHILE(@@FETCH_STATUS=0)
     BEGIN
            PRINT @NAME
            FETCH RELATIVE 5 FROM C1 INTO @NAME
      END
           CLOSE C1
           DEALLOCATE C1

 => write a prog to print names from last to first ?

DECLARE @name VARCHAR(10)
DECLARE C1 SCROLL CURSOR FOR SELECT ename FROM emp 
OPEN C1
FETCH Last FROM C1 INTO @name
WHILE(@@FETCH_STATUS = 0)
BEGIN
  PRINT @name
  FETCH prior FROM C1 INTO @name
END
CLOSE C1
DEALLOCATE C1

============================================================
 
 ERROR HANDLING / EXCEPTION HANDLING :- 
 -----------------------------------------------------------------
 
 1  syntax errors
 2  logical errors
 3  runtime errors

 => errors that are raised during program execution are called runtime errors

   ex :- 

 	 declare @a tinyint
	 set @a=1000      => runtime error
	 print @a 
 
=>  if any statement causes runtime error then sql server displays error
      message and continues program execution.

=> to display simple and user friendly message then we need to handle that
     error 

=> to handle that  error include a block called TRY---BATCH block

16-MAY-23

    BEGIN TRY
            statement1
            statement2            =>  stmts causes exception
            --------------
            statement N
    END TRY
    BEGIN CATCH
            statements            => stmts handles exception
    END CATCH

 => if any statement in try block causes exception then control is transferred   
      to catch block and executes the statements in catch block.

  example 1  :- 

  declare @a tinyint,@b tinyint,@c tinyint
  BEGIN TRY
  set @a=10
  set @b=222222
  set @c = @a/@b 
  print @c 
  END TRY
  BEGIN CATCH
     PRINT 'error' 
  END CATCH

 ERROR HANDLING FUNCTIONS :- 
 -----------------------------------------------

 1  ERROR_NUMBER()      =>  returns error code
 2  ERROR_MESSAGE()    =>  returns error message
 3  ERROR_SEVERITY()    =>  returns severity level
 4  ERROR_STATE()          =>  returns state
 5  ERROR_LINE()             =>   returns line number

example 1 :-

  declare @a tinyint,@b tinyint,@c tinyint
  begin try
  set @a=10
  set @b=0
  set @c = @a/@b 
  print @c 
  end try
  begin catch
       if error_number()=220 
              print  ' value exceeding limit'
      else if error_number()=8134
             print  ' divisor cannot be zero '
 end catch

example 2 :- 

 CREATE TABLE emp77
 (
   empno INT PRIMARY KEY,
   ename VARCHAR(10) NOT NULL,
   sal     MONEY  CHECK(sal>=3000)
 )

=> write a prog to insert data into emp77 table ?

  DECLARE @eno INT,@name VARCHAR(10),@sal MONEY
  BEGIN TRY
  SET @eno=100
  SET @name='A'
  SET @sal=5000
  INSERT INTO emp77 VALUES(@eno,@name,@sal)
  END TRY
  BEGIN CATCH
        IF ERROR_NUMBER() = 2627
               PRINT 'empno should not be duplicate'
       ELSE IF ERROR_NUMBER()=515
               PRINT ' name should not be null'
       ELSE IF ERROR_NUMBER()=547
              PRINT ' sal >= 3000'
  END CATCH

 USER DEFINED ERRORS :- 
 --------------------------------------

 => errors raised by user are called user defined errors. 
 => a user can raise error by using 
 
      RAISERROR(error msg,error severity level,state)

        severity level =>  0  to 25 

        state            =>   o to 255  => if the same error raised in multiple locations
                                                      by using this state we can identity
                                                      which part of the program causing that error

example 1  :- 

  declare @a tinyint,@b tinyint,@c tinyint
  begin try
  set @a=10
  set @b=0
  if @b=1
      raiserror(' divisor cannot be one ' , 15,1)
  set @c = @a/@b 
  print @c 
  end try
  begin catch
      if  error_number()=220
           print ' value exceeding limit '
      else if error_number() = 8134
           print ' divisor cannot be zero'
     else
          print  ' divisor cannot be one'
  end catch

 example 2 :- 

 ACCOUNTS
 ACCNO	ACTYPE	BAL 
100	S	10000
101	S	20000

 => write a prog to transfer amount from one acct to another acct ?

   DECLARE @SACNO INT,@TACNO INT,@AMT MONEY,@BAL MONEY
   DECLARE @MSG VARCHAR(500)
   BEGIN TRY
   SET @SACNO=100
   SET @TACNO=101
   SET @AMT=1000
   IF  NOT  EXISTS (SELECT * FROM ACCOUNTS 
                                                 WHERE ACCNO=@SACNO)
       RAISERROR(' SOURCE ACCOUNT DOES NOT EXISTS',15,1)

   IF NOT EXISTS (SELECT * FROM ACCOUNTS 
                                                WHERE ACCNO = @TACNO)
        RAISERROR('TARGET ACCOUNT DOES NOT EXISTS',15,1)
   
   SELECT @BAL = BAL FROM ACCOUNTS WHERE ACCNO = @SACNO

   IF @AMT > @BAL
         RAISERROR(' INSUFFICIENT BALANCE',15,1)
        
   UPDATE ACCOUNTS SET BAL = BAL - @AMT WHERE ACCNO = @SACNO
  
   UPDATE ACCOUNTS SET BAL = BAL + @AMT WHERE ACCNO = @TACNO
   END TRY
   BEGIN CATCH
      SET @MSG =  ERROR_MESSAGE()
      RAISERROR(@MSG,15,1)
  END CATCH
  
=> list of errors in sql server ?

   SELECT  * FROM SYS.MESSAGES 

 how to add user define error to sys.messages ?

  SP_ADDMESSAGE  ERROR CODE,SEVERITY LEVEL,MESSAGE

  EX :-  SP_ADDMESSAGE 50001,15,'sunday not allowed'

 => write a prog to input empno and increment salary by specific amount
      but sunday updates are not allowed ?

     DECLARE @ENO INT,@AMT MONEY
     SET @ENO = 7369
     SET @AMT=1000
     IF DATENAME(DW,GETDATE())='SUNDAY'
          RAISERROR(50001,15,1)
    ELSE
         UPDATE EMP SET SAL = SAL + @AMT WHERE EMPNO = @ENO 
 
 => how to remove user define error from sys.messages table ?

          SP_DROPMESSAGE 50001

===========================================================

 NAMED T-SQL BLOCKS :- 
 -----------------------------------

 1 STORED PROCEDURES
 2 FUNCTIONS 
 3 TRIGGERS 

 SUB-PROGRAMS :- 
 -------------------------
 
1  STORED PROCEDURES
2  FUNCTIONS 

Advantages :- 
-------------------

 1  modular programming :- 
 ----------------------------------- 

 => with the help of procedures & functions a big t-sql program can be
      divided into small modules.

2  reusability :- 
 -------------------

 =>  proc/func can be stored in db and applications which are connected
       to db can reuse these programs.

3 security :- 
---------------

 => because these programs are stored in db , so only authorized users
      can execute these programs.

4 invoked from front-end :- 
  ---------------------------------

 => proc/func can be called from front-end applications like java/.net etc

5  improves performance :- 
 -----------------------------------

 => when we create a procedure  program is parsed (compiled) and
      stored in db and whenever we call procedure only execution
      is repeated but not compilation , so this improves performance.

 STORED PROCEDURES :-  
 -------------------------------------

  => a procedure is a named T-SQL block that accepts some input
       performs some action on db and may or may not returns a value.
 
 => procedures are created to perform one or more dml operations over db.

 syn :- 

  CREATE OR ALTER PROCEDURE <NAME>
  parameters if any 
  AS
      STATEMENTS

parameters :- 
-------------------

=> we can declare parameters and we can pass values to parameters 

=> parameters are 2 types 

    1  INPUT  (default)
    2  OUTPUT

 => INPUT parameters always receives value
 => OUTPUT always sends value

example 1 :- (without parameters) 

 => create a procedure to increment all the employee salaries by 1000 ?

    CREATE OR ALTER PROCEDURE raise_salary
    AS
     UPDATE EMP SET SAL = SAL + 1000 

   procedure created (compiled + stored in db)

execution :- 

   EXECUTE  raise_salary 

example 2 :-  (procedure with parameters)

=> create a procedure to increment specific employee sal by specific amount ?
   
    CREATE OR ALTER PROCEDURE RAISE_SALARY
    @ENO  INT ,
    @AMT  MONEY
    AS
      UPDATE EMP SET SAL = SAL + @AMT WHERE EMPNO =  @ENO

execution :- 

 1    EXECUTE RAISE_SALARY 101,1000                       positional association

 2    EXECUTE  RAISE_SALARY @ENO=101,@AMT=1000  named association

 3    EXECUTE RAISE_SALARY @AMT=1000,@ENO=100  

example 3 :-  (procedure with output parameter)

=> create procedure to increment specific employee sal by specific amount
     after increment send the updated sal to calling program ?

     CREATE OR ALTER PROCEDURE  RAISE_SALARY
     @ENO INT ,
     @AMT MONEY,
     @NEWSAL MONEY OUTPUT
     AS
         UPDATE EMP SET SAL = SAL + @AMT WHERE EMPNO = @ENO
         SELECT @NEWSAL = SAL FROM EMP WHERE EMPNO = @ENO

 EXECUTION :- 

  DECLARE @S MONEY
  EXECUTE  RAISE_SALARY 101,1000,@S OUTPUT
  PRINT @S 

18-may-23

 parameters with default values :-
 ------------------------------------------

=> a parameter can be declared with default value as follows 

        @amt   money = 500

=> while executing procedure if we do not pass value to parameter then 
     sql server assigns default  value.

Example :- 

      CREATE OR ALTER PROCEDURE  RAISE_SALARY
     @ENO INT ,
     @AMT MONEY = 500,
     @NEWSAL MONEY OUTPUT
     AS
         UPDATE EMP SET SAL = SAL + @AMT WHERE EMPNO = @ENO
         SELECT @NEWSAL = SAL FROM EMP WHERE EMPNO = @ENO


execution :- 

declare @s money
execute raise_salary 101,DEFAULT,@s output 
print @s 

declare @s money
execute raise_salary @eno=101,@newsal=@s output
print @s 

example 5 :- 

ACCOUNTS
ACCNO	ACTYPE	BAL
100	S	10000
101	S	20000

=> create a procedure for money withdrawl ?

  CREATE OR ALTER PROCEDURE DEBIT
  @ACNO INT,
  @AMT  MONEY,
  @NEWBAL MONEY OUTPUT 
  AS
     DECLARE @BAL MONEY,@MSG  VARCHAR(100)
     BEGIN TRY
     IF NOT EXISTS (SELECT * FROM ACCOUNTS WHERE ACCNO = @ACNO)
            RAISERROR(' invalid accno ' ,15,1)
     SELECT  @BAL = BAL FROM ACCOUNTS WHERE ACCNO = @ACNO
     IF @AMT > @BAL 
          RAISERROR(' insufficient balance',15,1)
      UPDATE ACCOUNTS SET BAL = BAL - @AMT WHERE ACCNO = @ACNO
      SELECT @NEWBAL = BAL FROM ACCOUNTS WHERE ACCNO = @ACNO
      END TRY
      BEGIN CATCH
         SET @MSG = ERROR_MESSAGE()
         RAISERROR(@MSG,15,1)      
      END CATCH

 Execution :- 
 ---------------

  DECLARE @B MONEY
  EXECUTE DEBIT 100,1000,@B OUTPUT 
  PRINT @B 


=> create procedure for money deposit ? 

=> create procedure for money transfer ?

USER DEFINE FUNCTIONS :- 
-----------------------------------------
 
=>  functions created by user are called user define functions.
 
=>  when predefine functions not meeting our requirements then we 
      create our own functions called user define functions.

 => a function is also a named T-SQL block that accepts some input performs some
      calculation and must return a value.

=>  functions are created 

     1   for calculations
     2   to fetch value from db 

 => functions are 2 types 

     1  scalar valued functions
     2  table valued functions 

 SCALAR VALUED FUNCTIONS :- 
 --------------------------------------------

 => these functions returns one value
 => return type must be scalar type like int,varchar etc
 => returns expr must be a scalar variable

 SYN :- 

 CREATE OR ALTER 
           FUNCTION <NAME>(parameters if any)  RETURNS <TYPE> 
AS
BEGIN
          STATEMENTS
          RETURN <EXPR>
END

Example 1 :- 

 CREATE OR ALTER 
            FUNCTION CALC(@A INT,@B INT,@OP CHAR(1))  RETURNS INT
 AS
 BEGIN
       DECLARE  @C  INT
       IF @OP = '+' 
             SET @C = @A + @B 
       ELSE IF @OP='-'
             SET @C = @A - @B
       ELSE IF @OP='*'
             SET @C = @A*@B
       ELSE
            SET @C = @A/@B
       RETURN @C
 END

Executing :- 
---------------- 

    SELECT DBO.CALC(10,20,'*')    =>  200

 Example 2 :- 

 => create a function that accepts deptno and returns names of employees 
       working for the dept ?

       input  deptno = 20 

       output    :-  jones,scott,adams,ford

      CREATE OR ALTER 
               FUNCTION getNames(@dno INT) RETURNS   VARCHAR(1000)
      AS
      BEGIN
             DECLARE C1 CURSOR FOR SELECT ENAME FROM EMP WHERE DEPTNO=@dno
             DECLARE @NAME VARCHAR(10),@S VARCHAR(1000)= '  '
             OPEN C1
             FETCH NEXT FROM C1 INTO @NAME
             WHILE(@@FETCH_STATUS=0)
             BEGIN
                SET @S =  @S + @NAME + ','
                FETCH NEXT FROM C1 INTO @NAME
            END
                 CLOSE C1
                 DEALLOCATE C1
                 RETURN @S
      END


EXECUTION :- 

  SELECT DBO.GETNAMES(20)   =>   jones,scott,adams,ford

19-MAY-23 

 TABLE VALUED FUNCTIONS :- 
  ----------------------------------------

 => these functions returns records 
 => return type of these functions must be TABLE
 => return expression must be select statement
 => TVF allows only stmt and it must be return statement

 syn :- 

 CREATE OR ALTER FUNCTION <NAME>(parameters) RETURNS TABLE
 AS  
      RETURN (SELECT STMT)

 example 1 :- 

 => create a function that accept deptno and returns list of employees working for the dept ?

     CREATE OR ALTER 
            FUNCTION GETEMPLIST(@dno  INT) RETURNS TABLE
    AS
       RETURN (SELECT * FROM EMP WHERE DEPTNO = @dno)

 Execution :- 
 -----------------

  =>  TVFs are invoked in FROM clause

     SELECT * FROM DBO.GETEMPLIST(20) 


 example 2 :- 

 => create a function that returns top n employee list ?

     CREATE OR ALTER
          FUNCTION GETTOPNEMPLIST(@n INT) RETURNS TABLE
     AS
        RETURN ( SELECT *
                         FROM ( SELECT EMPNO,ENAME,SAL,
                                        DENSE_RANK() OVER (ORDER BY SAL DESC) AS RNK
                                     FROM EMP ) AS E
                          WHERE RNK<= @n )

  STRING_SPLIT :- 
  -----------------------

  => a table valued functions used to split one string into multiple strings based on seperator

                    STRING_SPLIT(STRING , SEPERATOR)

   EX :- 

     SELECT  * FROM STRING_SPLIT('SACHIN RAMESH TENDULKAR','  ')

     output :- 
 
    SACHIN 
    RAMESH
    TENDULKAR

STRING_AGG() :- 
----------------------------

 => it is scalar valued function used to concatenate column values 
 => converts multiple rows into one row

      STRING_AGG(COLNAME , SEPERATOR)

Ex :- 
 
SELECT STRING_AGG(ENAME,',') FROM EMP 

OUTPUT :- 

 ALLEN,WARD,JONES,MARTIN,BLAKE,---------


=> display  names of the employees working for each dept ?

  SELECT DEPTNO,STRING_AGG(ENAME,',')  AS NAMES
  FROM EMP 
  GROUP BY DEPTNO 
 
  10	CLARK,KING,MILLER
  20	FORD,ADAMS,SCOTT,JONES
  30	MARTIN,BLAKE,ALLEN,WARD,TURNER,JAMES

 Assignment :- 

ACCOUNTS
ACCNO	ACTYPE	BAL
 

TRANSACTIONS
TRID	TTYPE	TDATE	TAMT	ACCNO

CREATE SEQUENCE S1
START WITH 1
INCREMENT BY 1
MAXVALUE 99999

create following procedures & functions to implement various bank transactions ?

 1   ACCOUNT OPENING  (PROC)
 2   ACCOUNT CLOSING  (PROC)
 3   BALANCE ENQUIRY   (SCALAR FUNC)
 4   MONEY DEPOSIT       (PROC)
 5   MONEY WITHDRAWL (PROC)
 6   MONEY TRANSFER    (PROC)
 7   STATEMENT BETWEEN TWO GIVEN DATES  (TVF)
 8   LATEST N TRANSACTIONS OF PARTICULAR CUSTOMER (TVF)

 difference between scalar and table valued functions ?

                   SCALAR                                TABLE 

 1       returns one value                            returns records 

 2      return type must be                         return type must be table
         scalar types like 
         int,varchar

 3     return expression                             return expression must be 
        must be a scalar variable                 select stmt

 4     invoked in SELECT clause              invoked in FROM clause

 => difference between procedures and functions ?

           	PROCEDURES			FUNCTIONS 
 
     1	may or may not                        	must return a value
                returns a value   

     2	can return multiple values                        always returns one value

     3        returns values using OUTPUT                 returns value using return stmt
               parameter

    4         DML statements are allowed                    DML statements are not allowed in function
               in procedure 
 
    5         cannot be exeucted from                         can be executed from select command
               select command

    6         create procedure to                                 create function for calculations
               perform one or more                            
               dml operations

    7        create procedure to update balance          create function to get balance


 => to see the proc/func code  ? 

    SP_HELPTEXT    RAISE_SALARY 

 Droping :- 
 ------------
 
  DROP PROCEDURE RAISE_SALARY

  DROP FUNCTION DBO.CALC 

=> query to display list of procedures & functions ?
 
    SELECT * FROM INFORMATION_SCHEMA.ROUTINES
 
=============================================================================

20-MAY-23 

 TRIGGERS :-  
 -----------------

 =>  a trigger is also a named T-SQL block like procedure  but executed implicitly by sql server
       whenever user submits DML/DDL commands.

 => triggers are created 
 
     1  to control dml operations
     2  to enforce complex rules and validations
     3  to audit day-to-day operatios on tables
     4  to manage replicas
     5  to generate values for primary key columns 

syn :- 

 CREATE OR ALTER TRIGGER <NAME>
 ON <TABNAME>
 AFTER/INSETEAD OF  INSERT,UPDATE,DELETE
 AS
   STATEMENTS 

 
AFTER triggers :- 
---------------------

=> if trigger is after then sql server executes the trigger after executing dml

INSTEAD OF triggers :- 
--------------------------------

=> if trigger is instead of then sql server executes the trigger instead of 
     executing dml

 Examples :- 

 => create trigger to not to allow to insert,update,delete on emp table on sunday ?

    CREATE OR ALTER TRIGGER T1
    ON EMP
    AFTER INSERT,UPDATE,DELETE
    AS
       IF DATENAME(DW,GETDATE())='SUNDAY'
          BEGIN
                ROLLBACK
                RAISERROR(' sunday not allowed',15,1)
          END

Testing :- 

  UPDATE EMP SET SAL = 2000 WHERE EMPNO = 7844  => ERROR

=> create trigger to not to allow dmls on emp table before 10am and after 4pm ?

    CREATE OR ALTER TRIGGER T2
    ON EMP
    AFTER INSERT,UPDATE,DELETE
    AS
        IF DATEPART(HH,GETDATE()) < 10
            OR
            DATEPART(HH,GETDATE()) >= 16
       BEGIN
              ROLLBACK
              RAISERROR(' only between 10am and 4pm',15,1)
        END

Testing :- 
-------------

 UPDATE EMP SET SAL=3000 WHERE EMPNO = 107 

  ERROR :- 

  only between 10am and 4pm

=> create trigger to not to allow dmls on emp table as follows ?

    MON - FRI   <10AM AND >4PM
    SAT             <10AM AND >2PM 
    SUN            ------------------------

=> create trigger to not to update empno ?

 CREATE OR ALTER TRIGGER T3 
 ON EMP
 AFTER UPDATE
 AS
    IF UPDATE(EMPNO) 
         BEGIN
	 ROLLBACK
	 RAISERROR(' cannot update primary key ',15,1)
         END
 
 Testing :- 
 
 UPDATE EMP SET EMPNO = 222 WHERE EMPNO = 107

 ERROR :- 

  cannot update

How to disable & enable triggers ?

  DISABLE TRIGGER T2 ON EMP 

  ENABLE  TRIGGER T2 ON EMP 

 Magic tables :- 
 -------------------

 => The following two tables are created automatically during trigger execution

  1  INSERTED
  2  DELETED 

 => record user is trying to insert is copied to INSERTED table
 => record user is trying to delete is copied to DELETED table 
 => record user is trying to update is copied to INSERTED & DELETED table

INSERT INTO EMP
     VALUES(100,'ABC','CLERK',4000)  =>  INSERTED
                                                                 EMPNO ENAME JOB        SAL
                                                                 100        ABC     CLERK    4000

DELETE FROM EMP
      WHERE EMPNO = 7369       =>          DELETED
                                                                 EMPNO  ENAME   JOB       SAL
                                                                 7369       SMITH    CLERK   800

UPDATE EMP 
 SET SAL = 5000
WHERE EMPNO = 100               =>           INSERTED
                                                                  EMPNO  SAL
                                                                  100         5000

                                                                  DELETED
                                                                  EMPNO	 SAL
                                                                  100         4000

=> create trigger to not to allow to decrement salary ?

      CREATE OR ALTER TRIGGER T4
      ON EMP
      AFTER  UPDATE
      AS
         DECLARE @OLDSAL MONEY,@NEWSAL MONEY
         SELECT @OLDSAL=SAL FROM DELETED
         SELECT @NEWSAL=SAL FROM INSERTED
         IF @NEWSAL < @OLDSAL 
         BEGIN
             ROLLBACK
             RAISERROR(' sal cannot be decremented',15,1)
         END

Testing :- 
 
 UPDATE EMP SET SAL = SAL - 100 WHERE EMPNO = 7844 

 ERROR :- 

  sal cannot be decremented

22-may-23 

=> create trigger to insert details into emp_resign whenever employee resigns 
     from organization ?

   EMP_RESIGN
   EMPNO    ENAME    JOB	SAL      HIREDATE     DOR
    
  CREATE TABLE EMP_RESIGN
  (
  EMPNO   INT,
  ENAME   VARCHAR(10),
  JOB        VARCHAR(10),
  SAL         MONEY,
  HIREDATE DATE,
  DOR         DATE
 )

CREATE OR ALTER TRIGGER T5
ON EMP
AFTER DELETE
AS
    DECLARE @ENO INT,@NAME VARCHAR(10),@JOB VARCHAR(10),@SAL MONEY
    DECLARE @HIRE  DATE
    SELECT @ENO=EMPNO,@NAME=ENAME,@JOB=JOB,@SAL=SAL ,
                   @HIRE = HIREDATE
    FROM DELETED
    INSERT INTO EMP_RESIGN 
                        VALUES(@ENO,@NAME,@JOB,@SAL,@HIRE,GETDATE())
 
Testing :-

  DELETE FROM EMP WHERE EMPNO = 107   => DELETED 

  SELECT * FROM EMP_RESIGN 

  Auditing :- 
 --------------

 => Auditing means monitoring day-to-day activities on  tables 
 => triggers are created for auditing.
 => using trigger we can capture changes made to tables 
 
 example :- 

  EMP_AUDIT
  UNAME	  OPERATION    OPTIME   NEW_ENO   NEW_ENAME    NEW_SAL  OLD_ENO    OLD_ENAME   OLD_SAL
  DBO        INSERT            ??             100               A                         5000           NULL            NULL                 NULL
  DBO        UPDATE           ??             100              A                          6000           100               A                        5000
  DBO        DELETE           ??              NULL          NULL                   NULL          100                A                       6000

  CREATE TABLE EMP_AUDIT
  (
    UNAME   	VARCHAR(10),
    OPERATION 	VARCHAR(10),
    OPTIME         	DATETIME,
    NEW_ENO	INT,
    NEW_ENAME	VARCHAR(10),
    NEW_SAL	MONEY,
    OLD_ENO	INT,
    OLD_ENAME	VARCHAR(10),
    OLD_SAL	MONEY
   )

  CREATE OR ALTER TRIGGER T6
  ON EMP
  AFTER  INSERT,UPDATE,DELETE
  AS
     DECLARE @CNT1  INT ,@CNT2 INT ,@OP VARCHAR(10)
     DECLARE @OLDENO INT,@OLDENAME  VARCHAR(10),@OLDSAL MONEY
     DECLARE @NEWENO INT,@NEWENAME VARCHAR(10),@NEWSAL MONEY
     SET @CNT1 = COUNT(*) FROM INSERTED 
     SET @CNT2 = COUNT(*) FROM DELETED
     SELECT @OLDENO = EMPNO,@OLDENAME=ENAME,@OLDSAL=SAL FROM DELETED
     SELECT @NEWENO=EMPNO,@NEWENAME=ENAME,@NEWSAL=SAL FROM INSERTED
     IF @CNT1=1 AND @CNT2=0
              SET @OP = 'INSERT'
    ELSE IF @CNT1=0 AND @CNT2=1
             SET @OP = 'DELETE'
    ELSE
            SET @OP = 'UPDATE'
    INSERT INTO EMP_AUDIT
         VALUES(USER_NAME() , @OP,GETDATE(),
                          @NEWENO,@NEWENAME,@NEWSAL,@OLDENO,@OLDENAME,@OLDSAL)
 

Testing :- 

 
 INSERT INTO EMP(EMPNO,ENAME,SAL)  VALUES(555,'KKK',4000)

 UPDATE EMP SET SAL=5000 WHERE EMPNO=555 

 DELETE FROM EMP WHERE EMPNO = 555

 SELECT * fROM EMP_AUDIT 
 
  INSTEAD OF triggers :- 
 --------------------------------

 => if trigger is instead of then sql server  executes the trigger instead of executing dml

 => dml command is replaced with trigger

Example :- 

 
create trigger to not to allow more than 4 employees in a dept ?

EMP44
ENO	ENAME	DNO
1	A	10
2	B	10
3	C	10
4	D	10
5	E	10  => NOT ALLOWED 

CREATE TABLE EMP44
(
 ENO  	INT,
 ENAME   VARCHAR(10),
 DNO        INT
)

CREATE OR ALTER TRIGGER T7
ON EMP44
INSTEAD OF INSERT
AS
     DECLARE @ENO INT,@NAME VARCHAR(10),@DNO INT,@CNT  INT
     SELECT @CNT = COUNT(*) FROM EMP44 WHERE DNO = @DNO
     IF @CNT=4
         RAISERROR(' max 4 employees per dept',15,1)
     ELSE
         BEGIN
                SELECT @ENO=ENO,@NAME=ENAME,@DNO=DNO FROM INSERTED
                INSERT INTO EMP44 VALUES(@ENO,@NAME,@DNO)
          END
     


Testing :- 

  INSERT INTO EMP44 VALUES(1,'A',10) 
  INSERT INTO EMP44 VALUES(2,'A',10) 
  INSERT INTO EMP44 VALUES(3,'C',10) 
  INSERT INTO EMP44 VALUES(4,'D',10) 
  INSERT INTO EMP44 VALUES(5,'E',10)   => ERROR => max 4 employees per dept

 Droping trigger :- 
 --------------------

  DROP TRIGGER T2 

=================================================================== 

 Dynamic-SQL :- 
 -----------------------

 => SQL commands generated runtime are called dynamic sql commands

  ex :-       DROP    TABLE   EMP    (STATIC SQL)

  
               DECLARE @TNAME  VARCHAR(20)
               SET @TNAME = 'EMP'
               DROP TABLE @TNAME  (DYNAMIC SQL) 

 => Dynamic SQL is useful when we don't know tablenames and column names until runtime

 => Dynamic SQL commands are executed by using 

    1  EXEC
    2  SP_EXECUTESQL

 23-MAY-23

using EXEC :- 
-------------------

 => Dynamic SQL command that you want to execute should be passed as a string to EXEC

                EXEC ( ' Dynamic SQL command ' )

 example :- 

 => create a procedure to drop table from db ?

   CREATE OR ALTER PROCEDURE DROP_TABLE
   @TNAME     VARCHAR(20)
   AS
         EXEC ( ' DROP TABLE  '  + @TNAME  ) 


 EXECUTE  DROP_TABLE    'CUSTOMERS'
  

 =>  create procedure to drop all tables from db ?

  CREATE OR ALTER PROCEDURE DROP_ALL_TABLES
  AS
  DECLARE C1 CURSOR FOR  SELECT TABLE_NAME
                                                   FROM INFORMATION_SCHEMA.TABLES 
                                                   WHERE TABLE_TYPE='BASE TABLE'
 DECLARE @TNAME VARCHAR(20)
 OPEN C1
 FETCH NEXT FROM C1 INTO @TNAME
 WHILE(@@FETCH_STATUS=0)
 BEGIN
        EXEC (' DROP TABLE  ' + @TNAME)
         FETCH NEXT FROM C1 INTO @TNAME
  END
         CLOSE C1
         DEALLOCATE C1

 
   EXECUTE  DROP_ALL_TABLES 

   
using SP_EXECUTESQL :- 
--------------------------------------

 => it is a built-in stored procedured used to execute dynamic SQL commands 

     SP_EXECUTESQL   ' dynamic sql command ' 

=> write a prog to print no of rows in all the tables in db ?

     EMP      ?
     DEPT    ?
     CUST    ?

    DECLARE C1 CURSOR FOR SELECT TABLE_NAME
                                                     FROM INFORMATION_SCHEMA.TABLES
                                                    WHERE TABLE_TYPE='BASE TABLE'
     DECLARE @TNAME VARCHAR(20),@CMD   NVARCHAR(100)
     DECLARE @rows INT
     DECLARE @params  NVARCHAR(100) = ' @CNT INT OUTPUT '
     OPEN C1
     FETCH NEXT FROM C1 INTO @TNAME
     WHILE(@@FETCH_STATUS=0)
     BEGIN
          SET @CMD =   '  SELECT  @CNT = COUNT(*) FROM ' + @TNAME
          EXECUTE SP_EXECUTESQL  @CMD , @params , @CNT = @rows  OUTPUT
          PRINT  @TNAME + '    '   +  CAST (@rows AS VARCHAR)
          FETCH NEXT FROM C1 INTO @TNAME
    END
           CLOSE C1
           DEALLOCATE C1

 
 CURSORS
 PROCEDURES
 FUNCTIONS
 TRIGGERS
 DYNAMIC SQL 

=======================================================================

 Temporary Tables :- 
 ---------------------------

  => these tables stores data temporarly.

  => these tables are called temporary because they exists upto the session , once 
       session closes temporary tables are auotmatically destroyed.

  => Temporary tables are created in TempDB

  => Temporary tables are prefixed with '#' 

   Example :- 
 
   CREATE TABLE  #TEMP
   (
      RNO      INT,
      EMPID   INT,
      ENAME  VARCHAR(10),
      SAL        MONEY
    )

  inserting data into temporary table :- 
  -----------------------------------------------

   INSERT INTO #TEMP
   SELECT ROW_NUMBER() OVER (ORDER BY EMPNO ASC),EMPNO,ENAME,SAL 
   FROM EMP 

  SELECT * FROM #TEMP 

 TABLE variables :- 
 ------------------------

  => It is a variable that can store table records.

  => scope of the table variable is upto the program , once program execution is completed
       then table variables are destroyed

 => table variable is prefixed with '@' 

 Declaring table variable :- 
 ---------------------------------

 DECLARE @T TABLE
(
 ENO INT,
 ENAME VARCHAR(10),
 SAL MONEY
 )

 inserting data into table variable :-
 ----------------------------------------------

 INSERT INTO @T 
 SELECT EMPNO,ENAME,SAL FROM EMP 


 SELECT * FROM @T 

24-may-23 

 Backup & Restore :-  
 ---------------------------

 =>   DB must be protected various failures like  hardward,software and programs.
 =>   Backups are created to protect db from failures.
 =>   regularaly db is copied to backup files.
 =>   when db damages we can recover db from backup.
 =>   recovering db from backup is called restore.
 
how to take backup :-
----------------------------
 
=>  select database for ex  DB4PM => TASKS => BACKUP

      select  Backup Type  :-   FULL / DIFFERENTIAL

      FULL                   => full db is copied to backup file
      DIFFERENTIAL   => since last backup only changes are copied to backup file

       select destination   =>   DISK / URL

       select folder            =>   D:\BACKUPS\DB4PM.BAK

       click  OK 

   command to create backup :- 
   -------------------------------------

   BACKUP DATABASE [DB4PM] TO  DISK = N'D:\BACKUPS\DB4PM.BAK'   

   
   procedure to take backup of all databases :- 
   -------------------------------------------------------

   CREATE OR ALTER PROCEDURE  BACKUP_DBS
   AS
  DECLARE C1 CURSOR FOR  SELECT NAME
                                                   FROM SYS.DATABASES
                                                   WHERE DATABASE_ID > 4 
  DECLARE @DBNAME  VARCHAR(20)
  DECLARE @FNAME     VARCHAR(100)
  OPEN C1
  FETCH NEXT FROM C1 INTO @DBNAME
  WHILE(@@FETCH_STATUS=0)
  BEGIN
        SET @FNAME =   'D:\BACKUPS\' + @DBNAME + CONVERT(VARCHAR,GETDATE(),112) +  '.BAK'
        BACKUP DATABASE @DBNAME TO DISK = @FNAME
        FETCH NEXT FROM C1 INTO @DBNAME
  END
       CLOSE C1
       DEALLOCATE C1


 EXECUTE   BACKUP_DBS 

 Restoring Database :- 
 ------------------------------

 => select  Databases => Restore Database 

      1        select     source   :-   device 

       2       select backup file  :-   D:\BACKUPS\DB4PM.BAK

 => click ok

 command to restore database :- 
 --------------------------------------------

   RESTORE  DATABASE  DB4PM  FROM DISK =  'D:\BACKUPS\DB4PM.BAK' 

25-may-23 

  Normalization :- 
  --------------------

 => Normalization is the process of decomposing table with redundency into number of
      well structured tables 

 => Normalization is set of rules and each rule is called a normal form and there are
      six normal forms 

         1NF
         2NF
         3NF
         BCNF (boyce-codd NF)
         4NF
         5NF

 1NF :- 
 --------

  => a table said to be in 1NF if there are no multivalued attributes in it  or all the 
       attributes in table are atomic (single).

    BILL
    BILLNO     BDATE    CCODE   NAME   ADDR    ICODE   NAME   RATE   QTY   VALUE    TBILL
    100           25-           100        A            HYD       1
                                                                                2  
                               
                                                                                20 

     S                S             S           S           S             M           M          M        M        M            S

 =>  in the above example some attributes are single valued and some attributes are
       multi valued ,so the table is not according to 1NF , so decompose the table into
       two tables and establish relationship using foreign key.

 
   BILL
   BILLNO   BDATE    CCODE    NAME    ADDR     TBILL
   1000
   1001

  BILL_ITEMS
  BILLNO    ICODE    NAME   RATE    QTY     VALUE    
 --------------------------
   1000       1             A           100
   1000       2
   1000       3
   1001       1            A            100


 => in the above example if ICODE is repeated then  NAME,RATE are also repeated 
      

 2NF :- 
 ------------

  =>   a table said to be in 2NF

    1  if it is in 1NF
    2  if there are no partial dependencies in it.

 partial dependecy :- 
 -------------------------

  R(A,B,C,D)           A,B  => PRIMARY KEY 

    A,B -------> C      (FULL DEPENDENCY)
      
       B ---------->D    (PARTIAL DEPENDENCY)

 => if non key attribute depends on key attribute then it is called full dependency
 => if non key attributes depends on part of the key then it is called partial dependency

 TABLE 1 :- 

    BILL
   BILLNO   BDATE    CCODE    NAME    ADDR     TBILL
   -----------

  =>  in the above example  there is no composite primary key , so the table is according to 2NF

 TABLE 2 :- 
 
  BILL_ITEMS
  BILLNO    ICODE    NAME   RATE    QTY     VALUE    
  ------------------------ 
  
    BILLNO,ICODE -------->  QTY , VALUE  (FULL DEPENDENCY)
                 ICODE  --------> NAME , RATE  (PARTIAL DEPENDENCY)

 => above table contains partial dependencies , so the table is not according to 2NF       
      so decompose the table as follows 

     ITEMS
     ICODE    NAME    RATE 
    ----------


    BILL_ITEMS
    BILLNO    ICODE     QTY     VALUE
    ------------------------

 AFTER 2FN :- 
---------------------

   BILL
   BILLNO   BDATE    CCODE    NAME    ADDR     TBILL
   -----------

    ITEMS
    ICODE    NAME    RATE 
    ----------

    BILL_ITEMS
    BILLNO    ICODE     QTY     VALUE
    ------------------------
   
 3NF :- 
 ----------

 => a table said to be in 3NF 

   1 if it is in 2NF
   2 if there are no transitive dependencies in it 

  R(A,B,C,D)       A  => PRIMARY KEY 

  A------>B,C       (FULL DEPENDENCY) 

 C-------->D        (TRANSITIVE DEPENDENCY) 

 => in table if non key attribute depends on another non key attribute then it is called 
      transitive dependency

 TABLE  1  :-

    BILL
    BILLNO   BDATE    CCODE    NAME    ADDR     TBILL
    -----------

     BILLNO   -------> BDATE ,TBILL      (FULL )
     CCODE  --------->  NAME,ADDR     (TRANSITIVE)

 => above table contains transitive dependency , so the table is not according to 3NF then
      decompose the table as follows 

     CUST
     CCODE    NAME      ADDR
     ----------
 
     BILL
     BILLNO     BDATE      TBILL (calculated field)      CCODE 
     -----------
 
   TABLE 2 :-
                                     
     ITEMS
    ICODE    NAME    RATE 
    ----------

  TABLE 3 :-

    BILL_ITEMS
    BILLNO    ICODE     QTY     VALUE (calculated field)
    ------------------------

 AFTER 3NF :- 
 -------------------

     CUST
     CCODE    NAME      ADDR
     ----------

     BILL
     BILLNO     BDATE      CCODE 
     -----------

     ITEMS
    ICODE    NAME    RATE 
    ----------

    BILL_ITEMS
    BILLNO    ICODE     QTY     
    ------------------------


 








       


 
 






  




























      













